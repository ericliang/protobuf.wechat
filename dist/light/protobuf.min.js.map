{"version":3,"sources":["lib/prelude.js","../index","../src/EventEmitter.js","../src/asPromise.js","../src/base64.js","../src/common.js","../src/converter.js","../src/decoder.js","../src/encoder.js","../src/enum.js","../src/field.js","../src/float.js","../src/long.js","../src/longBits.js","../src/mapField.js","../src/message.js","../src/method.js","../src/namespace.js","../src/object.js","../src/oneof.js","../src/parse.js","../src/path.js","../src/pool.js","../src/reader.js","../src/root.js","../src/roots.js","../src/rpc/service.js","../src/service.js","../src/tokenize.js","../src/type.js","../src/types.js","../src/utf8.js","../src/util.js","../src/verifier.js","../src/wrappers.js","../src/writer.js"],"names":["undefined","modules","cache","protobuf","1","require","module","exports","load","filename","root","callback","Root","loadSync","parseFromPbString","pbString","configure","converter","_configure","decoder","encoder","Field","MapField","Message","Namespace","Method","ReflectionObject","OneOf","parse","Reader","Service","verifier","Type","types","wrappers","Writer","build","util","rpc","roots","tokenize","common","Enum","arguments","length","i","argument","hasOwnProperty","protobufFactory","EventEmitter","this","_listeners","prototype","on","evt","fn","ctx","push","off","listeners","splice","emit","args","apply","params","Array","offset","index","pending","Promise","resolve","reject","err","base64","string","p","n","Math","ceil","b64","s64","encode","buffer","start","end","t","parts","chunk","j","b","String","fromCharCode","slice","join","invalidEncoding","decode","c","charCodeAt","Error","test","timeType","commonRe","name","json","nested","google","Any","fields","type_url","type","id","value","Duration","seconds","nanos","Timestamp","Empty","Struct","keyType","Value","oneofs","kind","oneof","nullValue","numberValue","stringValue","boolValue","structValue","listValue","NullValue","values","NULL_VALUE","ListValue","rule","DoubleValue","FloatValue","Int64Value","UInt64Value","Int32Value","UInt32Value","BoolValue","StringValue","BytesValue","FieldMask","paths","get","file","valuePartial_fromObject","field","fieldIndex","propName","options","m","d","_types","ksi","ksiFlag","resolvedType","prop","keys","Object","repeated","typeDefault","TypeError","fullName","fromObject","isUnsigned","Long","fromValue","unsigned","parseInt","LongBits","low","high","toNumber","newBuffer","valuePartial_toObject","o","enums","toObject","isFinite","longs","toString","call","Number","bytes","mtype","fieldsArray","ctor","_i","map","ks","merge","copy","isArray","sort","compareFieldsById","repeatedFields","mapFields","normalFields","partOf","defaults","valuesById","long","split","ks2","_fieldsArray","indexOf","_util","r","l","create","k","len","pos","uint32","group","fieldId","find","skip","emptyObject","basic","longToHash","packed","c2","console","log","skipType","rfield","required","ProtocolError","instance","message","writer","wireType","ref","fork","mapKey","ldelim","optional","warn","$type","constructor","className","comment","comments","reserved","fromJSON","enm","toJSON","toJSONOptions","keepComments","add","isString","isInteger","isReservedId","isReservedName","allow_alias","remove","val","ruleRe","extend","isObject","toLowerCase","defaultValue","extensionField","declaringField","_packed","defineProperty","getOption","setOption","ifNotSet","resolved","parent","lookupTypeOrEnum","fromNumber","freeze","buf","utf8","write","emptyArray","fieldType","fieldRule","decorateType","decorateEnum","fieldName","default","factory","writeFloat_ieee754","writeUint","sign","isNaN","round","exponent","floor","LN2","pow","readFloat_ieee754","readUint","uint","mantissa","NaN","Infinity","writeFloat_f32_cpy","f32","f8b","writeFloat_f32_rev","readFloat_f32_cpy","readFloat_f32_rev","le","f64","writeDouble_ieee754","off0","off1","readDouble_ieee754","lo","hi","writeDouble_f64_cpy","writeDouble_f64_rev","readDouble_f64_cpy","readDouble_f64_rev","Float32Array","Uint8Array","writeFloatLE","writeFloatBE","readFloatLE","readFloatBE","bind","writeUintLE","writeUintBE","readUintLE","readUintBE","Float64Array","writeDoubleLE","writeDoubleBE","readDoubleLE","readDoubleBE","wasm","WebAssembly","Instance","Module","e","isLong","obj","INT_CACHE","UINT_CACHE","fromInt","cachedObj","fromBits","UZERO","ZERO","TWO_PWR_64_DBL","MAX_UNSIGNED_VALUE","TWO_PWR_63_DBL","MIN_VALUE","MAX_VALUE","neg","TWO_PWR_32_DBL","lowBits","highBits","pow_dbl","fromString","str","radix","RangeError","substring","radixToPower","result","size","min","power","mul","TWO_PWR_16_DBL","TWO_PWR_24","ONE","UONE","NEG_ONE","LongPrototype","toInt","isZero","isNegative","eq","radixLong","div","rem1","sub","rem","remDiv","digits","getHighBits","getHighBitsUnsigned","getLowBits","getLowBitsUnsigned","getNumBitsAbs","bit","eqz","isPositive","isOdd","isEven","equals","other","notEquals","neq","ne","lessThan","comp","lt","lessThanOrEqual","lte","greaterThan","gt","greaterThanOrEqual","gte","ge","compare","thisNeg","otherNeg","negate","not","addend","a48","a32","a16","a00","b48","b32","b16","c48","c32","c16","c00","subtract","subtrahend","multiply","multiplier","get_high","b00","divide","divisor","approx","res","div_u","div_s","toUnsigned","shru","shr","shl","max","log2","delta","approxRes","approxRem","modulo","rem_u","rem_s","mod","and","or","xor","shiftLeft","numBits","shiftRight","shiftRightUnsigned","shr_u","toSigned","toBytes","toBytesLE","toBytesBE","fromBytes","fromBytesLE","fromBytesBE","zero","zzEncode","zzDecode","zeroHash","from","toLong","fromHash","hash","toHash","mask","part0","part1","part2","resolvedKeyType","fieldKeyType","fieldValueType","properties","encodeDelimited","reader","decodeDelimited","verify","object","set","key","requestType","responseType","requestStream","responseStream","resolvedRequestType","resolvedResponseType","lookupType","arrayToJSON","array","_nestedArray","clearCache","namespace","addJSON","toArray","nestedArray","nestedJson","names","methods","getEnum","prev","setOptions","onAdd","onRemove","define","path","ptr","part","shift","resolveAll","lookup","filterTypes","parentAlreadyChecked","found","lookupEnum","lookupService","defineProperties","unshift","_handleAdd","_handleRemove","fieldNames","addFieldsToParent","oneofName","oneOfGetter","oneOfSetter","keepCase","base10Re","base10NegRe","base16Re","base16NegRe","base8Re","base8NegRe","numberRe","nameRe","typeRefRe","fqTypeRefRe","source","pkg","imports","weakImports","syntax","token","tn","alternateCommentMode","next","peek","cmnt","head","isProto3","applyCase","camelCase","illegal","insideTryCatch","line","readString","readValue","acceptTypeRef","parseFloat","parseNumber","readRanges","target","acceptStrings","parseId","acceptNegative","parsePackage","parseImport","whichImports","parseSyntax","parseCommon","parseOption","ifBlock","valueType","parseInlineOptions","parseMapField","parseField","parseOneOf","extensions","parseType","dummy","parseEnumValue","parseEnum","service","method","parseMethod","parseService","reference","parseExtension","fnIf","fnElse","trailingLine","lcFirst","ucFirst","parseGroup","isCustom","parseOptionValue","package","isAbsolute","normalize","replace","absolute","prefix","originPath","includePath","alreadyNormalized","alloc","SIZE","MAX","slab","indexOutOfRange","writeLength","create_array","ArrayBuffer","readLongVarint","bits","readFixed32_end","readFixed64","Buffer","isBuffer","BufferReader","_slice","subarray","int32","sint32","bool","fixed32","sfixed32","float","double","read","int64","uint64","sint64","fixed64","sfixed64","deferred","files","SYNC","JSON","resolvePath","self","asPromise","pbObj","finish","cb","process","parsed","fetch","sync","queued","weak","idx","lastIndexOf","altname","setTimeout","fs","readFileSync","isNode","exposeRe","tryHandleExtension","extendedType","sisterField","rpcImpl","requestDelimited","responseDelimited","rpcCall","requestCtor","responseCtor","request","response","endedByRPC","_methodsArray","inherited","methodsArray","rpcService","methodName","codegen","isReserved","q","s","delimRe","stringDoubleRe","stringSingleRe","setCommentRe","setCommentAltRe","setCommentSplitRe","whitespaceRe","unescapeRe","unescapeMap","0","unescape","$0","$1","commentType","commentText","commentLine","commentLineEmpty","stack","stringDelim","subject","charAt","setComment","commentOffset","lines","trim","isDoubleSlashCommentLine","startOffset","endOffset","findEndOfLine","lineText","cursor","re","lastIndex","match","exec","repeat","curr","isDoc","expected","actual","ret","_fieldsById","_oneofsArray","_ctor","fieldsById","oneofsArray","generateConstructor","ctorProperties","oneOfGetAndSet","fieldMap","setter","getter","filter","setup","wrapper","originalThis","typeName","bake","c1","pool","a","dst","src","decorateRoot","enumerable","newObj","attr","deepCopy","newobj","CustomError","captureStackTrace","sizeOrArray","stringToBytes","byteToString","arr","_arr","one","v","bytesLength","store","st","invalid","verifyValue","verifyKey","key32Re","key64Re","key2Re","invalidDes","seenFirstField","oneofPropName","substr","Op","noop","State","tail","states","writeByte","VarintOp","writeVarint64","writeFixed32","BufferWriter","_push","writeBytes","reset","$require","$module","global","amd"],"mappings":"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","file":"protobuf.min.js","sourcesContent":["(function prelude(modules, cache, entries) {\n\n    // This is the prelude used to bundle protobuf.js for the browser. Wraps up the CommonJS\n    // sources through a conflict-free require shim and is again wrapped within an iife that\n    // provides a minification-friendly `undefined` var plus a global \"use strict\" directive\n    // so that minification can remove the directives of each module.\n\n    function $require(name) {\n        var $module = cache[name];\n        if (!$module)\n            modules[name][0].call($module = cache[name] = { exports: {} }, $require, $module, $module.exports);\n        return $module.exports;\n    }\n\n    var protobuf = $require(entries[0]);\n\n    // Expose globally\n    protobuf.util.global.protobuf = protobuf;\n\n    // Be nice to AMD\n    if (typeof define === \"function\" && define.amd)\n        define([\"long\"], function(Long) {\n            if (Long && Long.isLong) {\n                protobuf.util.Long = Long;\n                protobuf.configure();\n            }\n            return protobuf;\n        });\n\n    // Be nice to CommonJS\n    if (typeof module === \"object\" && module && module.exports)\n        module.exports = protobuf;\n\n})/* end of prelude */","/**\n * Created by zhangmiao on 2018/3/13.\n */\n\n\n\n(function (protobufFactory){\n    //if (typeof define === 'function')//?\n    //    define('protobuf', protobufFactory);\n    //else\n        module.exports = protobufFactory();\n})(function(){\n    var protobuf = {};\n//app.globalData.protobuf = protobuf;\n\n    /**\n     * Build type, one of `\"full\"`, `\"light\"` or `\"minimal\"`.\n     * @name build\n     * @type {string}\n     * @const\n     */\n    protobuf.build = \"minimal\";\n\n// Serialization\n    protobuf.Writer       = require(35);\n    protobuf.encoder      = require(8);\n    protobuf.Reader       = require(23);\n\n// Utility\n    protobuf.util         = require(32);\n    protobuf.rpc          = require(26);\n    protobuf.roots        = require(25);\n    protobuf.verifier     = require(33);\n\n    protobuf.tokenize         = require(28);\n    protobuf.parse            = require(20);\n    protobuf.common           = require(5);\n\n    protobuf.ReflectionObject = require(18);\n    protobuf.Namespace        = require(17);\n    protobuf.Root             = require(24);\n    protobuf.Enum             = require(9);\n    protobuf.Type             = require(29);\n    protobuf.Field            = require(10);\n    protobuf.OneOf            = require(19);\n    protobuf.MapField         = require(14);\n    protobuf.Service          = require(27);\n    protobuf.Method           = require(16);\n    protobuf.converter        = require(6);\n    protobuf.decoder          = require(7);\n\n// Runtime\n    protobuf.Message          = require(15);\n    protobuf.wrappers         = require(34);\n\n// Utility\n    protobuf.types            = require(30);\n    protobuf.util             = require(32);\n\n    protobuf.configure    = configure;\n\n\n    function load(filename, root, callback) {\n        if (typeof root === \"function\") {\n            callback = root;\n            root = new protobuf.Root();\n        } else if (!root)\n            root = new protobuf.Root();\n        return root.load(filename, callback);\n    }\n\n    protobuf.load = load;\n\n    function loadSync(filename, root) {\n        if (!root)\n            root = new protobuf.Root();\n        return root.loadSync(filename);\n    }\n\n    protobuf.loadSync = loadSync;\n\n\n//weichatpbConfig\n    function parseFromPbString(pbString, root, callback){\n        if (typeof root === \"function\") {\n            callback = root;\n            root = new protobuf.Root();\n        } else if (!root)\n            root = new protobuf.Root();\n        return root.parseFromPbString(pbString, callback);\n    }\n\n    protobuf.parseFromPbString = parseFromPbString;\n\n    /**\n     * Reconfigures the library according to the environment.\n     * @returns {undefined}\n     */\n    function configure() {\n\n        protobuf.converter._configure();\n        protobuf.decoder._configure();\n        protobuf.encoder._configure();\n        protobuf.Field._configure();\n        protobuf.MapField._configure();\n        protobuf.Message._configure();\n        protobuf.Namespace._configure();\n        protobuf.Method._configure();\n        protobuf.ReflectionObject._configure();\n        protobuf.OneOf._configure();\n        protobuf.parse._configure();\n        protobuf.Reader._configure();\n        protobuf.Root._configure();\n        protobuf.Service._configure();\n        protobuf.verifier._configure();\n        protobuf.Type._configure();\n        protobuf.types._configure();\n        protobuf.wrappers._configure();\n        protobuf.Writer._configure();\n    }\n    configure();\n\n    if(arguments&&arguments.length){\n        for (var  i = 0 ;i < arguments.length; i++){\n            var argument = arguments[i];\n            if(argument.hasOwnProperty(\"exports\")){\n                argument.exports = protobuf;\n                return;\n            }\n        }\n    }\n    return protobuf;\n});\n\n\n","\"use strict\";\nmodule.exports = EventEmitter;\n\n/**\n * Constructs a new event emitter instance.\n * @classdesc A minimal event emitter.\n * @memberof util\n * @constructor\n */\nfunction EventEmitter() {\n\n    /**\n     * Registered listeners.\n     * @type {Object.<string,*>}\n     * @private\n     */\n    this._listeners = {};\n}\n\n/**\n * Registers an event listener.\n * @param {string} evt Event name\n * @param {function} fn Listener\n * @param {*} [ctx] Listener context\n * @returns {util.EventEmitter} `this`\n */\nEventEmitter.prototype.on = function on(evt, fn, ctx) {\n    (this._listeners[evt] || (this._listeners[evt] = [])).push({\n        fn  : fn,\n        ctx : ctx || this\n    });\n    return this;\n};\n\n/**\n * Removes an event listener or any matching listeners if arguments are omitted.\n * @param {string} [evt] Event name. Removes all listeners if omitted.\n * @param {function} [fn] Listener to remove. Removes all listeners of `evt` if omitted.\n * @returns {util.EventEmitter} `this`\n */\nEventEmitter.prototype.off = function off(evt, fn) {\n    if (evt === undefined)\n        this._listeners = {};\n    else {\n        if (fn === undefined)\n            this._listeners[evt] = [];\n        else {\n            var listeners = this._listeners[evt];\n            for (var i = 0; i < listeners.length;)\n                if (listeners[i].fn === fn)\n                    listeners.splice(i, 1);\n                else\n                    ++i;\n        }\n    }\n    return this;\n};\n\n/**\n * Emits an event by calling its listeners with the specified arguments.\n * @param {string} evt Event name\n * @param {...*} args Arguments\n * @returns {util.EventEmitter} `this`\n */\nEventEmitter.prototype.emit = function emit(evt) {\n    var listeners = this._listeners[evt];\n    if (listeners) {\n        var args = [],\n            i = 1;\n        for (; i < arguments.length;)\n            args.push(arguments[i++]);\n        for (i = 0; i < listeners.length;)\n            listeners[i].fn.apply(listeners[i++].ctx, args);\n    }\n    return this;\n};\n","\"use strict\";\nmodule.exports = asPromise;\n\n/**\n * Callback as used by {@link util.asPromise}.\n * @typedef asPromiseCallback\n * @type {function}\n * @param {Error|null} error Error, if any\n * @param {...*} params Additional arguments\n * @returns {undefined}\n */\n\n/**\n * Returns a promise from a node-style callback function.\n * @memberof util\n * @param {asPromiseCallback} fn Function to call\n * @param {*} ctx Function context\n * @param {...*} params Function arguments\n * @returns {Promise<*>} Promisified function\n */\nfunction asPromise(fn, ctx/*, varargs */) {\n    var params  = new Array(arguments.length - 1),\n        offset  = 0,\n        index   = 2,\n        pending = true;\n    while (index < arguments.length)\n        params[offset++] = arguments[index++];\n    return new Promise(function executor(resolve, reject) {\n        params[offset] = function callback(err/*, varargs */) {\n            if (pending) {\n                pending = false;\n                if (err)\n                    reject(err);\n                else {\n                    var params = new Array(arguments.length - 1),\n                        offset = 0;\n                    while (offset < params.length)\n                        params[offset++] = arguments[offset];\n                    resolve.apply(null, params);\n                }\n            }\n        };\n        try {\n            fn.apply(ctx || null, params);\n        } catch (err) {\n            if (pending) {\n                pending = false;\n                reject(err);\n            }\n        }\n    });\n}\n","\"use strict\";\n\n/**\n * A minimal base64 implementation for number arrays.\n * @memberof util\n * @namespace\n */\nvar base64 = module.exports;\n\n/**\n * Calculates the byte length of a base64 encoded string.\n * @param {string} string Base64 encoded string\n * @returns {number} Byte length\n */\nbase64.length = function length(string) {\n    var p = string.length;\n    if (!p)\n        return 0;\n    var n = 0;\n    while (--p % 4 > 1 && string.charAt(p) === \"=\")\n        ++n;\n    return Math.ceil(string.length * 3) / 4 - n;\n};\n\n// Base64 encoding table\nvar b64 = new Array(64);\n\n// Base64 decoding table\nvar s64 = new Array(123);\n\n// 65..90, 97..122, 48..57, 43, 47\nfor (var i = 0; i < 64;)\n    s64[b64[i] = i < 26 ? i + 65 : i < 52 ? i + 71 : i < 62 ? i - 4 : i - 59 | 43] = i++;\n\n/**\n * Encodes a buffer to a base64 encoded string.\n * @param {Uint8Array} buffer Source buffer\n * @param {number} start Source start\n * @param {number} end Source end\n * @returns {string} Base64 encoded string\n */\nbase64.encode = function encode(buffer, start, end) {\n    var parts = null,\n        chunk = [];\n    var i = 0, // output index\n        j = 0, // goto index\n        t;     // temporary\n    while (start < end) {\n        var b = buffer[start++];\n        switch (j) {\n            case 0:\n                chunk[i++] = b64[b >> 2];\n                t = (b & 3) << 4;\n                j = 1;\n                break;\n            case 1:\n                chunk[i++] = b64[t | b >> 4];\n                t = (b & 15) << 2;\n                j = 2;\n                break;\n            case 2:\n                chunk[i++] = b64[t | b >> 6];\n                chunk[i++] = b64[b & 63];\n                j = 0;\n                break;\n        }\n        if (i > 8191) {\n            (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));\n            i = 0;\n        }\n    }\n    if (j) {\n        chunk[i++] = b64[t];\n        chunk[i++] = 61;\n        if (j === 1)\n            chunk[i++] = 61;\n    }\n    if (parts) {\n        if (i)\n            parts.push(String.fromCharCode.apply(String, chunk.slice(0, i)));\n        return parts.join(\"\");\n    }\n    return String.fromCharCode.apply(String, chunk.slice(0, i));\n};\n\nvar invalidEncoding = \"invalid encoding\";\n\n/**\n * Decodes a base64 encoded string to a buffer.\n * @param {string} string Source string\n * @param {Uint8Array} buffer Destination buffer\n * @param {number} offset Destination offset\n * @returns {number} Number of bytes written\n * @throws {Error} If encoding is invalid\n */\nbase64.decode = function decode(string, buffer, offset) {\n    var start = offset;\n    var j = 0, // goto index\n        t;     // temporary\n    for (var i = 0; i < string.length;) {\n        var c = string.charCodeAt(i++);\n        if (c === 61 && j > 1)\n            break;\n        if ((c = s64[c]) === undefined)\n            throw Error(invalidEncoding);\n        switch (j) {\n            case 0:\n                t = c;\n                j = 1;\n                break;\n            case 1:\n                buffer[offset++] = t << 2 | (c & 48) >> 4;\n                t = c;\n                j = 2;\n                break;\n            case 2:\n                buffer[offset++] = (t & 15) << 4 | (c & 60) >> 2;\n                t = c;\n                j = 3;\n                break;\n            case 3:\n                buffer[offset++] = (t & 3) << 6 | c;\n                j = 0;\n                break;\n        }\n    }\n    if (j === 1)\n        throw Error(invalidEncoding);\n    return offset - start;\n};\n\n/**\n * Tests if the specified string appears to be base64 encoded.\n * @param {string} string String to test\n * @returns {boolean} `true` if probably base64 encoded, otherwise false\n */\nbase64.test = function test(string) {\n    return /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(string);\n};\n","module.exports = common;\n\nvar commonRe = /\\/|\\./;\n\n/**\n * Provides common type definitions.\n * Can also be used to provide additional google types or your own custom types.\n * @param {string} name Short name as in `google/protobuf/[name].proto` or full file name\n * @param {Object.<string,*>} json JSON definition within `google.protobuf` if a short name, otherwise the file's root definition\n * @returns {undefined}\n * @property {INamespace} google/protobuf/any.proto Any\n * @property {INamespace} google/protobuf/duration.proto Duration\n * @property {INamespace} google/protobuf/empty.proto Empty\n * @property {INamespace} google/protobuf/field_mask.proto FieldMask\n * @property {INamespace} google/protobuf/struct.proto Struct, Value, NullValue and ListValue\n * @property {INamespace} google/protobuf/timestamp.proto Timestamp\n * @property {INamespace} google/protobuf/wrappers.proto Wrappers\n * @example\n * // manually provides descriptor.proto (assumes google/protobuf/ namespace and .proto extension)\n * protobuf.common(\"descriptor\", descriptorJson);\n *\n * // manually provides a custom definition (uses my.foo namespace)\n * protobuf.common(\"my/foo/bar.proto\", myFooBarJson);\n */\nfunction common(name, json) {\n    if (!commonRe.test(name)) {\n        name = \"google/protobuf/\" + name + \".proto\";\n        json = { nested: { google: { nested: { protobuf: { nested: json } } } } };\n    }\n    common[name] = json;\n}\n\n// Not provided because of limited use (feel free to discuss or to provide yourself):\n//\n// google/protobuf/descriptor.proto\n// google/protobuf/source_context.proto\n// google/protobuf/type.proto\n//\n// Stripped and pre-parsed versions of these non-bundled files are instead available as part of\n// the repository or package within the google/protobuf directory.\n\ncommon(\"any\", {\n\n    /**\n     * Properties of a google.protobuf.Any message.\n     * @interface IAny\n     * @type {Object}\n     * @property {string} [typeUrl]\n     * @property {Uint8Array} [bytes]\n     * @memberof common\n     */\n    Any: {\n        fields: {\n            type_url: {\n                type: \"string\",\n                id: 1\n            },\n            value: {\n                type: \"bytes\",\n                id: 2\n            }\n        }\n    }\n});\n\nvar timeType;\n\ncommon(\"duration\", {\n\n    /**\n     * Properties of a google.protobuf.Duration message.\n     * @interface IDuration\n     * @type {Object}\n     * @property {number|Long} [seconds]\n     * @property {number} [nanos]\n     * @memberof common\n     */\n    Duration: timeType = {\n        fields: {\n            seconds: {\n                type: \"int64\",\n                id: 1\n            },\n            nanos: {\n                type: \"int32\",\n                id: 2\n            }\n        }\n    }\n});\n\ncommon(\"timestamp\", {\n\n    /**\n     * Properties of a google.protobuf.Timestamp message.\n     * @interface ITimestamp\n     * @type {Object}\n     * @property {number|Long} [seconds]\n     * @property {number} [nanos]\n     * @memberof common\n     */\n    Timestamp: timeType\n});\n\ncommon(\"empty\", {\n\n    /**\n     * Properties of a google.protobuf.Empty message.\n     * @interface IEmpty\n     * @memberof common\n     */\n    Empty: {\n        fields: {}\n    }\n});\n\ncommon(\"struct\", {\n\n    /**\n     * Properties of a google.protobuf.Struct message.\n     * @interface IStruct\n     * @type {Object}\n     * @property {Object.<string,IValue>} [fields]\n     * @memberof common\n     */\n    Struct: {\n        fields: {\n            fields: {\n                keyType: \"string\",\n                type: \"Value\",\n                id: 1\n            }\n        }\n    },\n\n    /**\n     * Properties of a google.protobuf.Value message.\n     * @interface IValue\n     * @type {Object}\n     * @property {string} [kind]\n     * @property {0} [nullValue]\n     * @property {number} [numberValue]\n     * @property {string} [stringValue]\n     * @property {boolean} [boolValue]\n     * @property {IStruct} [structValue]\n     * @property {IListValue} [listValue]\n     * @memberof common\n     */\n    Value: {\n        oneofs: {\n            kind: {\n                oneof: [\n                    \"nullValue\",\n                    \"numberValue\",\n                    \"stringValue\",\n                    \"boolValue\",\n                    \"structValue\",\n                    \"listValue\"\n                ]\n            }\n        },\n        fields: {\n            nullValue: {\n                type: \"NullValue\",\n                id: 1\n            },\n            numberValue: {\n                type: \"double\",\n                id: 2\n            },\n            stringValue: {\n                type: \"string\",\n                id: 3\n            },\n            boolValue: {\n                type: \"bool\",\n                id: 4\n            },\n            structValue: {\n                type: \"Struct\",\n                id: 5\n            },\n            listValue: {\n                type: \"ListValue\",\n                id: 6\n            }\n        }\n    },\n\n    NullValue: {\n        values: {\n            NULL_VALUE: 0\n        }\n    },\n\n    /**\n     * Properties of a google.protobuf.ListValue message.\n     * @interface IListValue\n     * @type {Object}\n     * @property {Array.<IValue>} [values]\n     * @memberof common\n     */\n    ListValue: {\n        fields: {\n            values: {\n                rule: \"repeated\",\n                type: \"Value\",\n                id: 1\n            }\n        }\n    }\n});\n\ncommon(\"wrappers\", {\n\n    /**\n     * Properties of a google.protobuf.DoubleValue message.\n     * @interface IDoubleValue\n     * @type {Object}\n     * @property {number} [value]\n     * @memberof common\n     */\n    DoubleValue: {\n        fields: {\n            value: {\n                type: \"double\",\n                id: 1\n            }\n        }\n    },\n\n    /**\n     * Properties of a google.protobuf.FloatValue message.\n     * @interface IFloatValue\n     * @type {Object}\n     * @property {number} [value]\n     * @memberof common\n     */\n    FloatValue: {\n        fields: {\n            value: {\n                type: \"float\",\n                id: 1\n            }\n        }\n    },\n\n    /**\n     * Properties of a google.protobuf.Int64Value message.\n     * @interface IInt64Value\n     * @type {Object}\n     * @property {number|Long} [value]\n     * @memberof common\n     */\n    Int64Value: {\n        fields: {\n            value: {\n                type: \"int64\",\n                id: 1\n            }\n        }\n    },\n\n    /**\n     * Properties of a google.protobuf.UInt64Value message.\n     * @interface IUInt64Value\n     * @type {Object}\n     * @property {number|Long} [value]\n     * @memberof common\n     */\n    UInt64Value: {\n        fields: {\n            value: {\n                type: \"uint64\",\n                id: 1\n            }\n        }\n    },\n\n    /**\n     * Properties of a google.protobuf.Int32Value message.\n     * @interface IInt32Value\n     * @type {Object}\n     * @property {number} [value]\n     * @memberof common\n     */\n    Int32Value: {\n        fields: {\n            value: {\n                type: \"int32\",\n                id: 1\n            }\n        }\n    },\n\n    /**\n     * Properties of a google.protobuf.UInt32Value message.\n     * @interface IUInt32Value\n     * @type {Object}\n     * @property {number} [value]\n     * @memberof common\n     */\n    UInt32Value: {\n        fields: {\n            value: {\n                type: \"uint32\",\n                id: 1\n            }\n        }\n    },\n\n    /**\n     * Properties of a google.protobuf.BoolValue message.\n     * @interface IBoolValue\n     * @type {Object}\n     * @property {boolean} [value]\n     * @memberof common\n     */\n    BoolValue: {\n        fields: {\n            value: {\n                type: \"bool\",\n                id: 1\n            }\n        }\n    },\n\n    /**\n     * Properties of a google.protobuf.StringValue message.\n     * @interface IStringValue\n     * @type {Object}\n     * @property {string} [value]\n     * @memberof common\n     */\n    StringValue: {\n        fields: {\n            value: {\n                type: \"string\",\n                id: 1\n            }\n        }\n    },\n\n    /**\n     * Properties of a google.protobuf.BytesValue message.\n     * @interface IBytesValue\n     * @type {Object}\n     * @property {Uint8Array} [value]\n     * @memberof common\n     */\n    BytesValue: {\n        fields: {\n            value: {\n                type: \"bytes\",\n                id: 1\n            }\n        }\n    }\n});\n\ncommon(\"field_mask\", {\n\n    /**\n     * Properties of a google.protobuf.FieldMask message.\n     * @interface IDoubleValue\n     * @type {Object}\n     * @property {number} [value]\n     * @memberof common\n     */\n    FieldMask: {\n        fields: {\n            paths: {\n                rule: \"repeated\",\n                type: \"string\",\n                id: 1\n            }\n        }\n    }\n});\n\n/**\n * Gets the root definition of the specified common proto file.\n *\n * Bundled definitions are:\n * - google/protobuf/any.proto\n * - google/protobuf/duration.proto\n * - google/protobuf/empty.proto\n * - google/protobuf/field_mask.proto\n * - google/protobuf/struct.proto\n * - google/protobuf/timestamp.proto\n * - google/protobuf/wrappers.proto\n *\n * @param {string} file Proto file name\n * @returns {INamespace|null} Root definition or `null` if not defined\n */\ncommon.get = function get(file) {\n    return common[file] || null;\n};\n","/**\n * Created by zhangmiao on 2018/3/14.\n * ,; ,Function.Apply evl,gen()\n */\nvar converter = module.exports;\n\nvar Enum,\n    util;\n\n\nconverter._configure = function () {\n    Enum = require(9);\n    util = require(32);\n};\n\nfunction valuePartial_fromObject(field, fieldIndex, propName, options){\n    var m       = options['m'];\n    var d       = options['d'];\n    var _types  = options['types'];\n    var ksi     = options['ksi'];\n    var ksiFlag = typeof ksi != 'undefined';\n    if(field.resolvedType){\n        if(field.resolvedType instanceof Enum){\n            var prop = ksiFlag ? d[propName][ksi] : d[propName];\n            var values = field.resolvedType.values,\n                keys = Object.keys(values);\n            for (var i = 0; i < keys.length; i++){\n                if(field.repeated && values[keys[i]] === field.typeDefault){\n                    continue;\n                }\n                if(keys[i] == prop || values[keys[i]] == prop){\n                    ksiFlag ?\n                        m[propName][ksi] = values[keys[i]] :\n                        m[propName] = values[keys[i]];\n                    break\n                }\n            }\n        }else {\n            if(typeof (ksiFlag ? d[propName][ksi] : d[propName]) !== 'object')\n                throw TypeError(field.fullName + \": object expected\");\n            ksiFlag ?\n                m[propName][ksi] = _types[fieldIndex].fromObject(d[propName][ksi]):\n                m[propName] = _types[fieldIndex].fromObject(d[propName]);\n        }\n    } else {\n        var  isUnsigned = false;\n        switch (field.type){\n            case \"double\":\n            case \"float\":\n                ksiFlag ?\n                    m[propName][ksi] = Number(d[propName][ksi]) :\n                    m[propName] = Number(d[propName]);\n                break;\n            case \"uint32\":\n            case \"fixed32\":\n                ksiFlag ?\n                    m[propName][ksi] = d[propName][ksi] >>> 0:\n                    m[propName] = d[propName] >>> 0;\n                break;\n            case \"int32\":\n            case \"sint32\":\n            case \"sfixed32\":\n                ksiFlag ?\n                    m[propName][ksi] = d[propName][ksi] | 0 :\n                    m[propName] = d[propName] |0;\n                break;\n            case \"uint64\":\n                isUnsigned = true;\n            // eslint-disable-line no-fallthrough\n            case \"int64\":\n            case \"sint64\":\n            case \"fixed64\":\n            case \"sfixed64\":\n                if(util.Long)\n                    ksiFlag ?\n                        m[propName][ksi] = util.Long.fromValue(d[propName][ksi]).unsigned = isUnsigned :\n                        m[propName] = util.Long.fromValue(d[propName]).unsigned = isUnsigned;\n                else if(typeof (ksiFlag ? d[propName][ksi] : d[propName]) === 'string')\n                    ksiFlag ?\n                        m[propName][ksi] =parseInt(d[propName][ksi], 10) :\n                        m[propName] =parseInt(d[propName], 10);\n                else if(typeof (ksiFlag ? d[propName][ksi] : d[propName]) === 'number')\n                    ksiFlag ?\n                        m[propName][ksi] = d[propName][ksi] :\n                        m[propName] = d[propName];\n                else if(typeof (ksiFlag ? d[propName][ksi] : d[propName]) === 'object')\n                    ksiFlag ?\n                        m[propName][ksi] = new util.LongBits(d[propName][ksi].low >>> 0, d[propName][ksi].high >>> 0).toNumber(isUnsigned) :\n                        m[propName] = new util.LongBits(d[propName].low >>> 0, d[propName].high >>> 0).toNumber(isUnsigned);\n                break;\n            case \"bytes\":\n                if(typeof (ksiFlag ? d[propName][ksi] : d[propName]) ===\"string\")\n                    ksiFlag ?\n                        util.base64.decode(d[propName][ksi],m[propName][ksi]=util.newBuffer(util.base64.length(d[propName][ksi])),0) :\n                        util.base64.decode(d[propName],m[propName]=util.newBuffer(util.base64.length(d[propName])),0);\n                else if((ksiFlag ? d[propName][ksi] : d[propName]).length)\n                    ksiFlag?\n                        m[propName][ksi]=d[propName][ksi] :\n                        m[propName]=d[propName];\n                break;\n            case \"string\":\n                ksiFlag?\n                    m[propName][ksi]=String(d[propName][ksi]) :\n                    m[propName]=String(d[propName]);\n                break;\n            case \"bool\":\n                ksiFlag?\n                    m[propName][ksi]=Boolean(d[propName][ksi]):\n                    m[propName]=Boolean(d[propName]);\n                break;\n        }\n    }\n}\n\n/*\n* @param {Type} mtype Message type\n* @returns {Function} Function instance\n*/\nconverter.fromObject = function fromObject(mtype){\n    var fields = mtype.fieldsArray;\n    return function (options){\n        return function (d){\n            if(d instanceof this.ctor)\n                return d;\n            if(!fields.length)\n                return new  this.ctor;\n\n            var  m = new this.ctor;\n            for (var i = 0; i < fields.length; ++i){\n                var field       = fields[i].resolve();\n                var propName    = field.name;\n                var _i;\n                if(field.map){\n                    if(d[propName]){\n                        if(typeof d[propName] !== 'object')\n                            throw TypeError(field.fullName + \": object expected\");\n                        m[propName] = {};\n                    }\n                    var ks = Object.keys(d[propName]);\n                    for ( _i = 0; _i<ks.length ; ++_i)\n                        valuePartial_fromObject(field, i, propName, util.merge(util.copy(options), {m:m,d:d,ksi : ks[_i]}));\n                }else if(field.repeated){\n                    if(d[propName]){\n                        if(!Array.isArray(d[propName]))\n                            throw TypeError(field.fullName + \": array expected\");\n                        m[propName] = [];\n                        for (_i = 0; _i < d[propName].length; ++_i) {\n                            valuePartial_fromObject(field, i, propName, util.merge(util.copy(options), {\n                                m: m,\n                                d: d,\n                                ksi: _i\n                            }));\n                        }\n                    }\n                }else {\n                    if((field.resolvedType instanceof Enum) || d[propName]!=null){\n                        valuePartial_fromObject(field,i,propName, util.merge(util.copy(options), {m:m,d:d}));\n                    }\n                }\n            }\n            return m;\n        }\n    }\n};\n\n\nfunction valuePartial_toObject (field, fieldIndex, propName, options){\n    var m       = options['m'];\n    var d       = options['d'];\n    var _types  = options['types'];\n    var ksi     = options['ksi'];\n    var o       = options['o'];\n    var ksiFlag = typeof ksi != 'undefined';\n    if(field.resolvedType){\n        if (field.resolvedType instanceof  Enum)\n            ksiFlag ?\n                (d[propName][ksi] = o.enums===String?_types[fieldIndex].values[m[propName][ksi]]:m[propName][ksi]) :\n                (d[propName] = o.enums===String?_types[fieldIndex].values[m[propName]]:m[propName]);\n        else\n            ksiFlag ?\n                d[propName][ksi] = _types[fieldIndex].toObject(m[propName][ksi], o) :\n                d[propName] = _types[fieldIndex].toObject(m[propName], o);\n    }else {\n        var isUnsigned = false;\n        switch (field.type) {\n            case \"double\":\n            case \"float\":\n                ksiFlag ? (d[propName][ksi] = o.json && !isFinite(m[propName][ksi])? String(m[propName][ksi]):m[propName][ksi]) :\n                    (d[propName] = o.json && !isFinite(m[propName])? String(m[propName]):m[propName]);\n                break;\n            case \"uint64\":\n                isUnsigned = true;\n            // eslint-disable-line no-fallthrough\n            case \"int64\":\n            case \"sint64\":\n            case \"fixed64\":\n            case \"sfixed64\":\n                if(typeof m[propName][ksi] === 'number')\n                    ksiFlag ?\n                        (d[propName][ksi] = o.longs === String ? String(m[propName][ksi]) : m[propName][ksi]) :\n                        (d[propName] = o.longs === String ? String(m[propName]) : m[propName]);\n                else\n                    ksiFlag ?\n                        (d[propName][ksi] =\n                        o.longs === String ?\n                            util.Long.prototype.toString.call(m[propName][ksi]) :\n                            o.longs === Number ? new  util.LongBits(m[propName][ksi].low >>> 0, m[propName][ksi].high >>> 0).toNumber(isUnsigned) : m[propName][ksi]):\n                        (d[propName] =\n                            o.longs === String ?\n                                util.Long.prototype.toString.call(m[propName]) :\n                                o.longs === Number ? new  util.LongBits(m[propName].low >>> 0, m[propName].high >>> 0).toNumber(isUnsigned) : m[propName]);\n                break;\n            case \"bytes\":\n                ksiFlag?\n                    (d[propName][ksi] =\n                    o.bytes === String ?\n                        util.base64.encode(m[propName][ksi], 0, m[propName][ksi].length) :\n                        o.bytes === Array ? Array.prototype.slice.call(m[propName][ksi]) : m[propName][ksi]):\n                    (d[propName] =\n                        o.bytes === String ?\n                            util.base64.encode(m[propName], 0, m[propName].length) :\n                            o.bytes === Array ? Array.prototype.slice.call(m[propName]) : m[propName]);\n                break;\n            default:\n                ksiFlag ? d[propName][ksi] = m[propName][ksi] : d[propName] = m[propName];\n                break;\n        }\n    }\n}\n\n\nconverter.toObject   = function toObject(mtype){\n    var fields = mtype.fieldsArray.slice().sort(util.compareFieldsById);\n    return function (options){\n        if(!fields.length)\n            return function (){\n                return {};\n            };\n        return function (m, o){\n            o = o || {};\n            var d = {};\n            var repeatedFields = [],\n                mapFields = [],\n                normalFields = [],\n                field,\n                propName,\n                i = 0;\n            for (; i < fields.length; ++i)\n                if (!fields[i].partOf)\n                    ( fields[i].resolve().repeated ? repeatedFields\n                        : fields[i].map ? mapFields\n                        : normalFields).push(fields[i]);\n\n            if (repeatedFields.length) {\n                if(o.arrays || o.defaults ){\n                    for (i = 0; i < repeatedFields.length; ++i)\n                        d[repeatedFields[i].name] = [];\n                }\n            }\n\n            if (mapFields.length) {\n                if(o.objects || o.defaults){\n                    for  (i = 0; i < mapFields.length; ++i)\n                        d[mapFields[i].name] = {};\n                }\n            }\n\n            if(normalFields.length){\n                if(o.defaults){\n                    for (i = 0; i < normalFields.length; ++i){\n                        field       = normalFields[i],\n                        propName    = field.name;\n                        if(field.resolvedType instanceof Enum)\n                            d[propName] = o.enums = String ? field.resolvedType.valuesById[field.typeDefault] : field.typeDefault;\n                        else if(field.long){\n                            if(util.Long){\n                                var n = new util.Long(field.typeDefault.low, field.typeDefault.high, field.typeDefault.unsigned);\n                                d[propName] = o.longs === String ? n.toString() : o.longs === Number ? n.toNumber():n;\n                            }else {\n                                d[propName] = o.longs === String ? field.typeDefault.toString() : field.typeDefault.toNumber();\n                            }\n                        }else if(field.bytes){\n                            d[propName] = o.bytes === String ? String.fromCharCode.apply(String, field.typeDefault) : Array.prototype.slice.call(field.typeDefault).join('*..*').split(\"*..*\");\n                        }else {\n                            d[propName] =field.typeDefault;\n                        }\n\n                    }\n                }\n            }\n            var hasKs2 = false;\n            for (i = 0; i < fields.length; ++i){\n                field       = fields[i];\n                propName    = field.name;\n                var index   = mtype._fieldsArray.indexOf(field);\n                var ks2;\n                var  j;\n                if(field.map){\n                    if (!hasKs2){\n                        hasKs2 = true;\n                    }\n                    if (m[propName]&&(ks2 = Object.keys(m[propName]).length)){\n                        d[propName] = {};\n                        for (j = 0; j < ks2.length; ++j){\n                            valuePartial_toObject(field, index, propName, util.merge(util.copy(options), {m:m,d:d,ksi :ks2[j],o:o}));\n                        }\n                    }\n                }else if(field.repeated){\n                    if(m[propName]&&m[propName].length){\n                        d[propName] = [];\n                        for (j = 0; j < m[propName].length; ++j){\n                            valuePartial_toObject(field, index, propName, util.merge(util.copy(options), {m:m,d:d,ksi:j,o:o}))\n                        }\n                    }\n                }else {\n                    if(m[propName]!=null&& (m.hasOwnProperty(propName)/*|| field.partOf*/)){\n                        valuePartial_toObject(field, index, propName, util.merge(util.copy(options), {m:m,d:d,o:o}))\n                    }\n                    if(field.partOf) {\n                        if (o.oneofs)\n                            d[field.partOf.name] = propName;\n                    }\n                }\n            }\n            return d;\n        }\n    }\n\n\n};","/**\n * Created by zhangmiao on 2018/3/13.\n */\n\nvar Enum,\n    types,\n    util;\n\n\nfunction missing(field) {\n    return \"missing required '\" + field.name + \"'\";\n}\n\nfunction decoder(mtype){\n    return function (options){\n        var Reader = options.Reader;\n        var _types = options.types;\n        var _util   = options.util;\n        return function (r, l){\n            if(!(r instanceof Reader))\n                r = Reader.create(r);\n            var c = l === undefined ? r.len : r.pos + l,\n                m = new this.ctor;\n            var k;\n            while (r.pos < c){\n                var t = r.uint32();\n                if (mtype.group){\n                    if((t&7) === 4)\n                        break;\n                }\n                var fieldId = t>>>3;\n                var i = 0;\n                var find = false;\n                for (; i < mtype.fieldsArray.length; ++i){\n                    var field = mtype._fieldsArray[i].resolve(),\n                        name  = field.name,\n                        type  = field.resolvedType instanceof Enum ? \"int32\" : field.type;\n                        //ref   = m[field.name];\n                    if (fieldId != field.id) continue;\n                    find = true;\n                    if (field.map){\n                        r.skip().pos++;\n                        if(m[name] === _util.emptyObject)\n                            m[name] = {};\n                        k = r[field.keyType]();\n                        r.pos++;\n                        if(types.long[field.keyType] != undefined){\n                            if(types.basic[type] == undefined){\n                                m[name][typeof k ==='object' ? _util.longToHash(k):k] = _types[i].decode(r, r.uint32());\n                            }else {\n                                m[name][typeof k ==='object' ? _util.longToHash(k):k] = r[type]();\n                            }\n                        }else {\n                            if(types.basic[type] == undefined){\n                                m[name] = _types[i].decode(r, r.uint32());\n                            }else {\n                                m[name] = r[type]();\n                            }\n                        }\n                    }else if(field.repeated){\n                        if(!(m[name] && m[name].length)){\n                            m[name] = [];\n                        }\n\n                        if(types.packed[type] != undefined && (t&7) === 2){\n                            var c2 = r.uint32()+ r.pos;\n                            while (r.pos < c2)\n                                m[name].push(r[type]())\n                        }else {\n                            if(types.basic[type] == undefined){\n                                field.resolvedType.group ?\n                                    m[name].push(_types[i].decode(r)) :\n                                    m[name].push(_types[i].decode(r, r.uint32()))\n\n                            }else {\n                                m[name].push(r[type]());\n                            }\n                        }\n                    }else if (types.basic[type] == undefined){\n                        if(field.resolvedType.group){\n                            m[name] = _types[i].decode(r);\n                        }else {\n                            m[name] = _types[i].decode(r, r.uint32());\n                        }\n                    }else {\n                        //console.log(\"m\",JSON.stringify(m),\"type\",type,\"field\",field);\n                        m[name] = r[type]();\n                    }\n                    break;\n                }\n\n                if(!find){\n                    console.log(\"t\",t);\n                    r.skipType(t&7)\n                }\n\n            }\n\n            for (i = 0; i < mtype._fieldsArray.length; ++ i){\n                var rfield = mtype._fieldsArray[i];\n                if(rfield.required){\n                    if(!m.hasOwnProperty(rfield.name)){\n                        throw util.ProtocolError(missing(rfield),{instance:m})\n                    }\n                }\n            }\n            //mtype.fieldsArray.filter(function(field) { return field.map; }).length\n            return m;\n        }\n    }\n}\n\nmodule.exports = decoder;\ndecoder._configure  = function (){\n    Enum    = require(9);\n    types   = require(30);\n    util    = require(32);\n};","/**\n * Created by zhangmiao on 2018/3/13.\n * googleProtocolBufferencode,;/(o)/~~\n */\nvar Enum;\nvar types;\n\n\n//\nfunction encoder(mtype){\n    return function (options){\n        var Writer = options.Writer;\n        var _types  = options.types;\n        var util   = options.util;\n        return function (message, writer) {\n            writer = writer || Writer.create();\n            var fields = mtype.fieldsArray.slice().sort(util.compareFieldsById);\n            for (var i = 0; i < fields.length; i++) {\n                var field = fields[i];\n                var index = mtype._fieldsArray.indexOf(field);\n\n                var type = field.resolvedType instanceof Enum ? 'uint32' : field.type;\n                var wireType = types.basic[type];\n                var ref      = message[field.name];\n                //,string,number\n                if(field.resolvedType instanceof Enum && typeof ref === 'string'){\n                    ref = _types[index]['values'][ref];\n                }\n\n                //\n                if (field.map) {//\n                    if(ref != null && message.hasOwnProperty(field.name)){\n                        for (var  ks =Object.keys(ref), l = 0; l < ks.length; ++l){\n                            writer.uint32((field.id << 3 | 2) >>> 0).fork().uint32(8 | types.mapKey[field.keyType])[field.keyType](ks[l]);\n                            if(wireType === undefined ){\n                                _types[index].encode(ref[ks[l]], writer.uint32(18).fork()).ldelim().ldelim();\n                            }else {\n                                writer.uint32(16 | wireType)[type](ref[ks[l]]).ldelim();\n                            }\n                        }\n                    }\n                } else if (field.repeated) {\n                    if (ref && ref.length) {\n                        if (field.packed && types.packed[type] !== undefined) {//packed\n                            writer.uint32((field.id << 3 | 2) >>> 0).fork();\n                            for (var j = 0; j < ref.length; j++) {\n                                writer[type](ref[j])\n                            }\n                            writer.ldelim();\n                        } else {//packed\n                            for (var k = 0; k < ref.length; k++) {\n                                if (wireType === undefined) {//\n                                    if(field.resolvedType.group){\n                                        _types[index].encode(ref[k],writer.uint32((field.id << 3 | 3) >>> 0)).uint32((field.id << 3 | 4) >>> 0);\n                                    }else {\n                                        _types[index].encode(ref[k],writer.uint32((field.id << 3 | 2) >>> 0).fork()).ldelim();\n                                    }\n                                } else {//string  bytes\n                                    writer.uint32((field.id << 3 | wireType) >>> 0)[type](ref[k]);\n                                }\n                            }\n                        }\n                    }\n                } else {\n                    if(!field.optional || (ref != null && (message.hasOwnProperty(field.name) /*|| field.partOf*/))){\n                        if(!field.optional && (ref == null || !message.hasOwnProperty(field.name))){\n                            console.warn('!!! :',message.$type ? message.$type.name : \"\",':',field.name,'protorequired');\n                        }\n                        if(wireType === undefined){\n                            if(field.resolvedType.group){\n                                _types[index].encode(ref,writer.uint32((field.id << 3 | 3) >>> 0)).uint32((field.id << 3 | 4) >>> 0);\n                            }else {\n                                _types[index].encode(ref,writer.uint32((field.id << 3 | 2) >>> 0).fork()).ldelim();\n                            }\n                        }else {\n                            writer.uint32((field.id << 3 | wireType) >>> 0)[type](ref);\n                        }\n                    }\n                }\n            }\n            return writer;\n        }\n    };\n}\n\nmodule.exports = encoder;\n\nencoder._configure  = function (){\n    Enum    = require(9);\n    types   = require(30);\n};","/**\n * Created by zhangmiao on 2018/3/12.\n */\n\nmodule.exports = Enum;\n\nvar ReflectionObject = require(18);\n\n((Enum.prototype = Object.create(ReflectionObject.prototype)).constructor = Enum).className = \"Enum\";\nvar Namespace = require(17);\n\nfunction Enum(name, values, options, comment, comments) {\n    ReflectionObject.call(this, name, options);\n\n    if (values && typeof values !== \"object\")\n        throw TypeError(\"values must be an object\");\n\n    /**\n     * Enum values by id.\n     * @type {Object.<number,string>}\n     */\n    this.valuesById = {};\n\n    /**\n     * Enum values by name.\n     * @type {Object.<string,number>}\n     */\n    this.values = Object.create(this.valuesById); // toJSON, marker\n\n    /**\n     * Enum comment text.\n     * @type {string|null}\n     */\n    this.comment = comment;\n\n    /**\n     * Value comment texts, if any.\n     * @type {Object.<string,string>}\n     */\n    this.comments = comments || {};\n\n    /**\n     * Reserved ranges, if any.\n     * @type {Array.<number[]|string>}\n     */\n    this.reserved = undefined; // toJSON\n\n    // Note that values inherit valuesById on their prototype which makes them a TypeScript-\n    // compatible enum. This is used by pbts to write actual enum definitions that work for\n    // static and reflection code alike instead of emitting generic object definitions.\n\n    if (values)\n        for (var keys = Object.keys(values), i = 0; i < keys.length; ++i)\n            if (typeof values[keys[i]] === \"number\") // use forward entries only\n                this.valuesById[ this.values[keys[i]] = values[keys[i]] ] = keys[i];\n}\n\n/**\n * Enum descriptor.\n * @interface IEnum\n * @property {Object.<string,number>} values Enum values\n * @property {Object.<string,*>} [options] Enum options\n */\n\n/**\n * Constructs an enum from an enum descriptor.\n * @param {string} name Enum name\n * @param {IEnum} json Enum descriptor\n * @returns {Enum} Created enum\n * @throws {TypeError} If arguments are invalid\n */\nEnum.fromJSON = function fromJSON(name, json) {\n    var enm = new Enum(name, json.values, json.options, json.comment, json.comments);\n    enm.reserved = json.reserved;\n    return enm;\n};\n\n/**\n * Converts this enum to an enum descriptor.\n * @param {IToJSONOptions} [toJSONOptions] JSON conversion options\n * @returns {IEnum} Enum descriptor\n */\nEnum.prototype.toJSON = function toJSON(toJSONOptions) {\n    var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;\n    return util.toObject([\n        \"options\"  , this.options,\n        \"values\"   , this.values,\n        \"reserved\" , this.reserved && this.reserved.length ? this.reserved : undefined,\n        \"comment\"  , keepComments ? this.comment : undefined,\n        \"comments\" , keepComments ? this.comments : undefined\n    ]);\n};\n\n/**\n * Adds a value to this enum.\n * @param {string} name Value name\n * @param {number} id Value id\n * @param {string} [comment] Comment, if any\n * @returns {Enum} `this`\n * @throws {TypeError} If arguments are invalid\n * @throws {Error} If there is already a value with this name or id\n */\nEnum.prototype.add = function add(name, id, comment) {\n    // utilized by the parser but not by .fromJSON\n\n    if (!util.isString(name))\n        throw TypeError(\"name must be a string\");\n\n    if (!util.isInteger(id))\n        throw TypeError(\"id must be an integer\");\n\n    if (this.values[name] !== undefined)\n        throw Error(\"duplicate name '\" + name + \"' in \" + this);\n\n    if (this.isReservedId(id))\n        throw Error(\"id \" + id + \" is reserved in \" + this);\n\n    if (this.isReservedName(name))\n        throw Error(\"name '\" + name + \"' is reserved in \" + this);\n\n    if (this.valuesById[id] !== undefined) {\n        if (!(this.options && this.options.allow_alias))\n            throw Error(\"duplicate id \" + id + \" in \" + this);\n        this.values[name] = id;\n    } else\n        this.valuesById[this.values[name] = id] = name;\n\n    this.comments[name] = comment || null;\n    return this;\n};\n\n/**\n * Removes a value from this enum\n * @param {string} name Value name\n * @returns {Enum} `this`\n * @throws {TypeError} If arguments are invalid\n * @throws {Error} If `name` is not a name of this enum\n */\nEnum.prototype.remove = function remove(name) {\n\n    if (!util.isString(name))\n        throw TypeError(\"name must be a string\");\n\n    var val = this.values[name];\n    if (val == null)\n        throw Error(\"name '\" + name + \"' does not exist in \" + this);\n\n    delete this.valuesById[val];\n    delete this.values[name];\n    delete this.comments[name];\n\n    return this;\n};\n\n/**\n * Tests if the specified id is reserved.\n * @param {number} id Id to test\n * @returns {boolean} `true` if reserved, otherwise `false`\n */\nEnum.prototype.isReservedId = function isReservedId(id) {\n    return Namespace.isReservedId(this.reserved, id);\n};\n\n/**\n * Tests if the specified name is reserved.\n * @param {string} name Name to test\n * @returns {boolean} `true` if reserved, otherwise `false`\n */\nEnum.prototype.isReservedName = function isReservedName(name) {\n    return Namespace.isReservedName(this.reserved, name);\n};","/**\n * Created by zhangmiao on 2018/3/12.\n */\n\nmodule.exports = Field;\n\n// extends ReflectionObject\nvar ReflectionObject = require(18);\n((Field.prototype = Object.create(ReflectionObject.prototype)).constructor = Field).className = \"Field\";\n\nvar Enum,\n    types,\n    util;\n\nvar Type; // cyclic\n\nvar ruleRe = /^required|optional|repeated$/;\n\n/**\n * Constructs a new message field instance. Note that {@link MapField|map fields} have their own class.\n * @name Field\n * @classdesc Reflected message field.\n * @extends FieldBase\n * @constructor\n * @param {string} name Unique name within its namespace\n * @param {number} id Unique id within its namespace\n * @param {string} type Value type\n * @param {string|Object.<string,*>} [rule=\"optional\"] Field rule\n * @param {string|Object.<string,*>} [extend] Extended type if different from parent\n * @param {Object.<string,*>} [options] Declared options\n */\n\n/**\n * Constructs a field from a field descriptor.\n * @param {string} name Field name\n * @param {IField} json Field descriptor\n * @returns {Field} Created field\n * @throws {TypeError} If arguments are invalid\n */\nField.fromJSON = function fromJSON(name, json) {\n    return new Field(name, json.id, json.type, json.rule, json.extend, json.options, json.comment);\n};\n\n/**\n * Not an actual constructor. Use {@link Field} instead.\n * @classdesc Base class of all reflected message fields. This is not an actual class but here for the sake of having consistent type definitions.\n * @exports FieldBase\n * @extends ReflectionObject\n * @constructor\n * @param {string} name Unique name within its namespace\n * @param {number} id Unique id within its namespace\n * @param {string} type Value type\n * @param {string|Object.<string,*>} [rule=\"optional\"] Field rule\n * @param {string|Object.<string,*>} [extend] Extended type if different from parent\n * @param {Object.<string,*>} [options] Declared options\n * @param {string} [comment] Comment associated with this field\n */\nfunction Field(name, id, type, rule, extend, options, comment) {\n\n    if (util.isObject(rule)) {\n        comment = extend;\n        options = rule;\n        rule = extend = undefined;\n    } else if (util.isObject(extend)) {\n        comment = options;\n        options = extend;\n        extend = undefined;\n    }\n\n    ReflectionObject.call(this, name, options);\n\n    if (!util.isInteger(id) || id < 0)\n        throw TypeError(\"id must be a non-negative integer\");\n\n    if (!util.isString(type))\n        throw TypeError(\"type must be a string\");\n\n    if (rule !== undefined && !ruleRe.test(rule = rule.toString().toLowerCase()))\n        throw TypeError(\"rule must be a string rule\");\n\n    if (extend !== undefined && !util.isString(extend))\n        throw TypeError(\"extend must be a string\");\n\n    /**\n     * Field rule, if any.\n     * @type {string|undefined}\n     */\n    this.rule = rule && rule !== \"optional\" ? rule : undefined; // toJSON\n\n    /**\n     * Field type.\n     * @type {string}\n     */\n    this.type = type; // toJSON\n\n    /**\n     * Unique field id.\n     * @type {number}\n     */\n    this.id = id; // toJSON, marker\n\n    /**\n     * Extended type if different from parent.\n     * @type {string|undefined}\n     */\n    this.extend = extend || undefined; // toJSON\n\n    /**\n     * Whether this field is required.\n     * @type {boolean}\n     */\n    this.required = rule === \"required\";\n\n    /**\n     * Whether this field is optional.\n     * @type {boolean}\n     */\n    this.optional = !this.required;\n\n    /**\n     * Whether this field is repeated.\n     * @type {boolean}\n     */\n    this.repeated = rule === \"repeated\";\n\n    /**\n     * Whether this field is a map or not.\n     * @type {boolean}\n     */\n    this.map = false;\n\n    /**\n     * Message this field belongs to.\n     * @type {Type|null}\n     */\n    this.message = null;\n\n    /**\n     * OneOf this field belongs to, if any,\n     * @type {OneOf|null}\n     */\n    this.partOf = null;\n\n    /**\n     * The field type's default value.\n     * @type {*}\n     */\n    this.typeDefault = null;\n\n    /**\n     * The field's default value on prototypes.\n     * @type {*}\n     */\n    this.defaultValue = null;\n\n    /**\n     * Whether this field's value should be treated as a long.\n     * @type {boolean}\n     */\n    this.long = util.Long ? types.long[type] !== undefined : /* istanbul ignore next */ false;\n\n    /**\n     * Whether this field's value is a buffer.\n     * @type {boolean}\n     */\n    this.bytes = type === \"bytes\";\n\n    /**\n     * Resolved type if not a basic type.\n     * @type {Type|Enum|null}\n     */\n    this.resolvedType = null;\n\n    /**\n     * Sister-field within the extended type if a declaring extension field.\n     * @type {Field|null}\n     */\n    this.extensionField = null;\n\n    /**\n     * Sister-field within the declaring namespace if an extended field.\n     * @type {Field|null}\n     */\n    this.declaringField = null;\n\n    /**\n     * Internally remembers whether this field is packed.\n     * @type {boolean|null}\n     * @private\n     */\n    this._packed = null;\n\n    /**\n     * Comment for this field.\n     * @type {string|null}\n     */\n    this.comment = comment;\n}\n\n/**\n * Determines whether this field is packed. Only relevant when repeated and working with proto2.\n * @name Field#packed\n * @type {boolean}\n * @readonly\n */\nObject.defineProperty(Field.prototype, \"packed\", {\n    get: function() {\n        // defaults to packed=true if not explicity set to false\n        if (this._packed === null)\n            this._packed = this.getOption(\"packed\") !== false;\n        return this._packed;\n    }\n});\n\n/**\n * @override\n */\nField.prototype.setOption = function setOption(name, value, ifNotSet) {\n    if (name === \"packed\") // clear cached before setting\n        this._packed = null;\n    return ReflectionObject.prototype.setOption.call(this, name, value, ifNotSet);\n};\n\n/**\n * Field descriptor.\n * @interface IField\n * @property {string} [rule=\"optional\"] Field rule\n * @property {string} type Field type\n * @property {number} id Field id\n * @property {Object.<string,*>} [options] Field options\n */\n\n/**\n * Extension field descriptor.\n * @interface IExtensionField\n * @extends IField\n * @property {string} extend Extended type\n */\n\n/**\n * Converts this field to a field descriptor.\n * @param {IToJSONOptions} [toJSONOptions] JSON conversion options\n * @returns {IField} Field descriptor\n */\nField.prototype.toJSON = function toJSON(toJSONOptions) {\n    var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;\n    return util.toObject([\n        \"rule\"    , this.rule !== \"optional\" && this.rule || undefined,\n        \"type\"    , this.type,\n        \"id\"      , this.id,\n        \"extend\"  , this.extend,\n        \"options\" , this.options,\n        \"comment\" , keepComments ? this.comment : undefined\n    ]);\n};\n\n/**\n * Resolves this field's type references.\n * @returns {Field} `this`\n * @throws {Error} If any reference cannot be resolved\n */\nField.prototype.resolve = function resolve() {\n\n    if (this.resolved)\n        return this;\n\n    if ((this.typeDefault = types.defaults[this.type]) === undefined) { // if not a basic type, resolve it\n        this.resolvedType = (this.declaringField ? this.declaringField.parent : this.parent).lookupTypeOrEnum(this.type);\n        if (this.resolvedType instanceof Type)\n            this.typeDefault = null;\n        else // instanceof Enum\n            this.typeDefault = this.resolvedType.values[Object.keys(this.resolvedType.values)[0]]; // first defined\n    }\n\n    // use explicitly set default value if present\n    if (this.options && this.options[\"default\"] != null) {\n        this.typeDefault = this.options[\"default\"];\n        if (this.resolvedType instanceof Enum && typeof this.typeDefault === \"string\")\n            this.typeDefault = this.resolvedType.values[this.typeDefault];\n    }\n\n    // remove unnecessary options\n    if (this.options) {\n        if (this.options.packed === true || this.options.packed !== undefined && this.resolvedType && !(this.resolvedType instanceof Enum))\n            delete this.options.packed;\n        if (!Object.keys(this.options).length)\n            this.options = undefined;\n    }\n\n    // convert to internal data type if necesssary\n    if (this.long) {\n        this.typeDefault = util.Long.fromNumber(this.typeDefault, this.type.charAt(0) === \"u\");\n\n        /* istanbul ignore else */\n        if (Object.freeze)\n            Object.freeze(this.typeDefault); // long instances are meant to be immutable anyway (i.e. use small int cache that even requires it)\n\n    } else if (this.bytes && typeof this.typeDefault === \"string\") {\n        var buf;\n        //if (util.base64.test(this.typeDefault))\n        //    util.base64.decode(this.typeDefault, buf = util.newBuffer(util.base64.length(this.typeDefault)), 0);\n        //else\n            util.utf8.write(this.typeDefault, buf = util.newBuffer(util.utf8.length(this.typeDefault)), 0);\n        this.typeDefault = buf;\n    }\n\n    // take special care of maps and repeated fields\n    if (this.map)\n        this.defaultValue = util.emptyObject;\n    else if (this.repeated)\n        this.defaultValue = util.emptyArray;\n    else\n        this.defaultValue = this.typeDefault;\n\n    // ensure proper value on prototype\n    if (this.parent instanceof Type) {\n        this.parent.ctor.prototype[this.name] = this.defaultValue;\n    }\n    return ReflectionObject.prototype.resolve.call(this);\n};\n\n/**\n * Decorator function as returned by {@link Field.d} and {@link MapField.d} (TypeScript).\n * @typedef FieldDecorator\n * @type {function}\n * @param {Object} prototype Target prototype\n * @param {string} fieldName Field name\n * @returns {undefined}\n */\n\n/**\n * Field decorator (TypeScript).\n * @name Field.d\n * @function\n * @param {number} fieldId Field id\n * @param {\"double\"|\"float\"|\"int32\"|\"uint32\"|\"sint32\"|\"fixed32\"|\"sfixed32\"|\"int64\"|\"uint64\"|\"sint64\"|\"fixed64\"|\"sfixed64\"|\"string\"|\"bool\"|\"bytes\"|Object} fieldType Field type\n * @param {\"optional\"|\"required\"|\"repeated\"} [fieldRule=\"optional\"] Field rule\n * @param {T} [defaultValue] Default value\n * @returns {FieldDecorator} Decorator function\n * @template T extends number | number[] | Long | Long[] | string | string[] | boolean | boolean[] | Uint8Array | Uint8Array[] | Buffer | Buffer[]\n */\nField.d = function decorateField(fieldId, fieldType, fieldRule, defaultValue) {\n\n    // submessage: decorate the submessage and use its name as the type\n    if (typeof fieldType === \"function\")\n        fieldType = util.decorateType(fieldType).name;\n\n    // enum reference: create a reflected copy of the enum and keep reuseing it\n    else if (fieldType && typeof fieldType === \"object\")\n        fieldType = util.decorateEnum(fieldType).name;\n\n    return function fieldDecorator(prototype, fieldName) {\n        util.decorateType(prototype.constructor)\n            .add(new Field(fieldName, fieldId, fieldType, fieldRule, { \"default\": defaultValue }));\n    };\n};\n\n/**\n * Field decorator (TypeScript).\n * @name Field.d\n * @function\n * @param {number} fieldId Field id\n * @param {Constructor<T>|string} fieldType Field type\n * @param {\"optional\"|\"required\"|\"repeated\"} [fieldRule=\"optional\"] Field rule\n * @returns {FieldDecorator} Decorator function\n * @template T extends Message<T>\n * @variation 2\n */\n// like Field.d but without a default value\n\nField._configure = function configure() {\n    Type = require(29);\n\n    Enum  = require(9);\n    types = require(30);\n    util  = require(32);\n};\n","module.exports = factory(factory);\n\n/**\n * Reads / writes floats / doubles from / to buffers.\n * @name util.float\n * @namespace\n */\n\n/**\n * Writes a 32 bit float to a buffer using little endian byte order.\n * @name util.float.writeFloatLE\n * @function\n * @param {number} val Value to write\n * @param {Uint8Array} buf Target buffer\n * @param {number} pos Target buffer offset\n * @returns {undefined}\n */\n\n/**\n * Writes a 32 bit float to a buffer using big endian byte order.\n * @name util.float.writeFloatBE\n * @function\n * @param {number} val Value to write\n * @param {Uint8Array} buf Target buffer\n * @param {number} pos Target buffer offset\n * @returns {undefined}\n */\n\n/**\n * Reads a 32 bit float from a buffer using little endian byte order.\n * @name util.float.readFloatLE\n * @function\n * @param {Uint8Array} buf Source buffer\n * @param {number} pos Source buffer offset\n * @returns {number} Value read\n */\n\n/**\n * Reads a 32 bit float from a buffer using big endian byte order.\n * @name util.float.readFloatBE\n * @function\n * @param {Uint8Array} buf Source buffer\n * @param {number} pos Source buffer offset\n * @returns {number} Value read\n */\n\n/**\n * Writes a 64 bit double to a buffer using little endian byte order.\n * @name util.float.writeDoubleLE\n * @function\n * @param {number} val Value to write\n * @param {Uint8Array} buf Target buffer\n * @param {number} pos Target buffer offset\n * @returns {undefined}\n */\n\n/**\n * Writes a 64 bit double to a buffer using big endian byte order.\n * @name util.float.writeDoubleBE\n * @function\n * @param {number} val Value to write\n * @param {Uint8Array} buf Target buffer\n * @param {number} pos Target buffer offset\n * @returns {undefined}\n */\n\n/**\n * Reads a 64 bit double from a buffer using little endian byte order.\n * @name util.float.readDoubleLE\n * @function\n * @param {Uint8Array} buf Source buffer\n * @param {number} pos Source buffer offset\n * @returns {number} Value read\n */\n\n/**\n * Reads a 64 bit double from a buffer using big endian byte order.\n * @name util.float.readDoubleBE\n * @function\n * @param {Uint8Array} buf Source buffer\n * @param {number} pos Source buffer offset\n * @returns {number} Value read\n */\n\n// Factory function for the purpose of node-based testing in modified global environments\nfunction factory(exports) {\n\n    // float: typed array\n    if (typeof Float32Array !== \"undefined\") (function() {\n\n        var f32 = new Float32Array([ -0 ]),\n            f8b = new Uint8Array(f32.buffer),\n            le  = f8b[3] === 128;\n\n        function writeFloat_f32_cpy(val, buf, pos) {\n            f32[0] = val;\n            buf[pos    ] = f8b[0];\n            buf[pos + 1] = f8b[1];\n            buf[pos + 2] = f8b[2];\n            buf[pos + 3] = f8b[3];\n        }\n\n        function writeFloat_f32_rev(val, buf, pos) {\n            f32[0] = val;\n            buf[pos    ] = f8b[3];\n            buf[pos + 1] = f8b[2];\n            buf[pos + 2] = f8b[1];\n            buf[pos + 3] = f8b[0];\n        }\n\n        /* istanbul ignore next */\n        exports.writeFloatLE = le ? writeFloat_f32_cpy : writeFloat_f32_rev;\n        /* istanbul ignore next */\n        exports.writeFloatBE = le ? writeFloat_f32_rev : writeFloat_f32_cpy;\n\n        function readFloat_f32_cpy(buf, pos) {\n            f8b[0] = buf[pos    ];\n            f8b[1] = buf[pos + 1];\n            f8b[2] = buf[pos + 2];\n            f8b[3] = buf[pos + 3];\n            return f32[0];\n        }\n\n        function readFloat_f32_rev(buf, pos) {\n            f8b[3] = buf[pos    ];\n            f8b[2] = buf[pos + 1];\n            f8b[1] = buf[pos + 2];\n            f8b[0] = buf[pos + 3];\n            return f32[0];\n        }\n\n        /* istanbul ignore next */\n        exports.readFloatLE = le ? readFloat_f32_cpy : readFloat_f32_rev;\n        /* istanbul ignore next */\n        exports.readFloatBE = le ? readFloat_f32_rev : readFloat_f32_cpy;\n\n        // float: ieee754\n    })(); else (function() {\n\n        function writeFloat_ieee754(writeUint, val, buf, pos) {\n            var sign = val < 0 ? 1 : 0;\n            if (sign)\n                val = -val;\n            if (val === 0)\n                writeUint(1 / val > 0 ? /* positive */ 0 : /* negative 0 */ 2147483648, buf, pos);\n            else if (isNaN(val))\n                writeUint(2143289344, buf, pos);\n            else if (val > 3.4028234663852886e+38) // +-Infinity\n                writeUint((sign << 31 | 2139095040) >>> 0, buf, pos);\n            else if (val < 1.1754943508222875e-38) // denormal\n                writeUint((sign << 31 | Math.round(val / 1.401298464324817e-45)) >>> 0, buf, pos);\n            else {\n                var exponent = Math.floor(Math.log(val) / Math.LN2),\n                    mantissa = Math.round(val * Math.pow(2, -exponent) * 8388608) & 8388607;\n                writeUint((sign << 31 | exponent + 127 << 23 | mantissa) >>> 0, buf, pos);\n            }\n        }\n\n        exports.writeFloatLE = writeFloat_ieee754.bind(null, writeUintLE);\n        exports.writeFloatBE = writeFloat_ieee754.bind(null, writeUintBE);\n\n        function readFloat_ieee754(readUint, buf, pos) {\n            var uint = readUint(buf, pos),\n                sign = (uint >> 31) * 2 + 1,\n                exponent = uint >>> 23 & 255,\n                mantissa = uint & 8388607;\n            return exponent === 255\n                ? mantissa\n                ? NaN\n                : sign * Infinity\n                : exponent === 0 // denormal\n                ? sign * 1.401298464324817e-45 * mantissa\n                : sign * Math.pow(2, exponent - 150) * (mantissa + 8388608);\n        }\n\n        exports.readFloatLE = readFloat_ieee754.bind(null, readUintLE);\n        exports.readFloatBE = readFloat_ieee754.bind(null, readUintBE);\n\n    })();\n\n    // double: typed array\n    if (typeof Float64Array !== \"undefined\") (function() {\n\n        var f64 = new Float64Array([-0]),\n            f8b = new Uint8Array(f64.buffer),\n            le  = f8b[7] === 128;\n\n        function writeDouble_f64_cpy(val, buf, pos) {\n            f64[0] = val;\n            buf[pos    ] = f8b[0];\n            buf[pos + 1] = f8b[1];\n            buf[pos + 2] = f8b[2];\n            buf[pos + 3] = f8b[3];\n            buf[pos + 4] = f8b[4];\n            buf[pos + 5] = f8b[5];\n            buf[pos + 6] = f8b[6];\n            buf[pos + 7] = f8b[7];\n        }\n\n        function writeDouble_f64_rev(val, buf, pos) {\n            f64[0] = val;\n            buf[pos    ] = f8b[7];\n            buf[pos + 1] = f8b[6];\n            buf[pos + 2] = f8b[5];\n            buf[pos + 3] = f8b[4];\n            buf[pos + 4] = f8b[3];\n            buf[pos + 5] = f8b[2];\n            buf[pos + 6] = f8b[1];\n            buf[pos + 7] = f8b[0];\n        }\n\n        /* istanbul ignore next */\n        exports.writeDoubleLE = le ? writeDouble_f64_cpy : writeDouble_f64_rev;\n        /* istanbul ignore next */\n        exports.writeDoubleBE = le ? writeDouble_f64_rev : writeDouble_f64_cpy;\n\n        function readDouble_f64_cpy(buf, pos) {\n            f8b[0] = buf[pos    ];\n            f8b[1] = buf[pos + 1];\n            f8b[2] = buf[pos + 2];\n            f8b[3] = buf[pos + 3];\n            f8b[4] = buf[pos + 4];\n            f8b[5] = buf[pos + 5];\n            f8b[6] = buf[pos + 6];\n            f8b[7] = buf[pos + 7];\n            return f64[0];\n        }\n\n        function readDouble_f64_rev(buf, pos) {\n            f8b[7] = buf[pos    ];\n            f8b[6] = buf[pos + 1];\n            f8b[5] = buf[pos + 2];\n            f8b[4] = buf[pos + 3];\n            f8b[3] = buf[pos + 4];\n            f8b[2] = buf[pos + 5];\n            f8b[1] = buf[pos + 6];\n            f8b[0] = buf[pos + 7];\n            return f64[0];\n        }\n\n        /* istanbul ignore next */\n        exports.readDoubleLE = le ? readDouble_f64_cpy : readDouble_f64_rev;\n        /* istanbul ignore next */\n        exports.readDoubleBE = le ? readDouble_f64_rev : readDouble_f64_cpy;\n\n        // double: ieee754\n    })(); else (function() {\n\n        function writeDouble_ieee754(writeUint, off0, off1, val, buf, pos) {\n            var sign = val < 0 ? 1 : 0;\n            if (sign)\n                val = -val;\n            if (val === 0) {\n                writeUint(0, buf, pos + off0);\n                writeUint(1 / val > 0 ? /* positive */ 0 : /* negative 0 */ 2147483648, buf, pos + off1);\n            } else if (isNaN(val)) {\n                writeUint(0, buf, pos + off0);\n                writeUint(2146959360, buf, pos + off1);\n            } else if (val > 1.7976931348623157e+308) { // +-Infinity\n                writeUint(0, buf, pos + off0);\n                writeUint((sign << 31 | 2146435072) >>> 0, buf, pos + off1);\n            } else {\n                var mantissa;\n                if (val < 2.2250738585072014e-308) { // denormal\n                    mantissa = val / 5e-324;\n                    writeUint(mantissa >>> 0, buf, pos + off0);\n                    writeUint((sign << 31 | mantissa / 4294967296) >>> 0, buf, pos + off1);\n                } else {\n                    var exponent = Math.floor(Math.log(val) / Math.LN2);\n                    if (exponent === 1024)\n                        exponent = 1023;\n                    mantissa = val * Math.pow(2, -exponent);\n                    writeUint(mantissa * 4503599627370496 >>> 0, buf, pos + off0);\n                    writeUint((sign << 31 | exponent + 1023 << 20 | mantissa * 1048576 & 1048575) >>> 0, buf, pos + off1);\n                }\n            }\n        }\n\n        exports.writeDoubleLE = writeDouble_ieee754.bind(null, writeUintLE, 0, 4);\n        exports.writeDoubleBE = writeDouble_ieee754.bind(null, writeUintBE, 4, 0);\n\n        function readDouble_ieee754(readUint, off0, off1, buf, pos) {\n            var lo = readUint(buf, pos + off0),\n                hi = readUint(buf, pos + off1);\n            var sign = (hi >> 31) * 2 + 1,\n                exponent = hi >>> 20 & 2047,\n                mantissa = 4294967296 * (hi & 1048575) + lo;\n            return exponent === 2047\n                ? mantissa\n                ? NaN\n                : sign * Infinity\n                : exponent === 0 // denormal\n                ? sign * 5e-324 * mantissa\n                : sign * Math.pow(2, exponent - 1075) * (mantissa + 4503599627370496);\n        }\n\n        exports.readDoubleLE = readDouble_ieee754.bind(null, readUintLE, 0, 4);\n        exports.readDoubleBE = readDouble_ieee754.bind(null, readUintBE, 4, 0);\n\n    })();\n\n    return exports;\n}\n\n// uint helpers\n\nfunction writeUintLE(val, buf, pos) {\n    buf[pos    ] =  val        & 255;\n    buf[pos + 1] =  val >>> 8  & 255;\n    buf[pos + 2] =  val >>> 16 & 255;\n    buf[pos + 3] =  val >>> 24;\n}\n\nfunction writeUintBE(val, buf, pos) {\n    buf[pos    ] =  val >>> 24;\n    buf[pos + 1] =  val >>> 16 & 255;\n    buf[pos + 2] =  val >>> 8  & 255;\n    buf[pos + 3] =  val        & 255;\n}\n\nfunction readUintLE(buf, pos) {\n    return (buf[pos    ]\n        | buf[pos + 1] << 8\n        | buf[pos + 2] << 16\n        | buf[pos + 3] << 24) >>> 0;\n}\n\nfunction readUintBE(buf, pos) {\n    return (buf[pos    ] << 24\n        | buf[pos + 1] << 16\n        | buf[pos + 2] << 8\n        | buf[pos + 3]) >>> 0;\n}\n","module.exports = Long;\n\n/**\n * wasm optimizations, to do native i64 multiplication and divide\n */\nvar wasm = null;\n\ntry {\n    wasm = new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([\n        0, 97, 115, 109, 1, 0, 0, 0, 1, 13, 2, 96, 0, 1, 127, 96, 4, 127, 127, 127, 127, 1, 127, 3, 7, 6, 0, 1, 1, 1, 1, 1, 6, 6, 1, 127, 1, 65, 0, 11, 7, 50, 6, 3, 109, 117, 108, 0, 1, 5, 100, 105, 118, 95, 115, 0, 2, 5, 100, 105, 118, 95, 117, 0, 3, 5, 114, 101, 109, 95, 115, 0, 4, 5, 114, 101, 109, 95, 117, 0, 5, 8, 103, 101, 116, 95, 104, 105, 103, 104, 0, 0, 10, 191, 1, 6, 4, 0, 35, 0, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 126, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 127, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 128, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 129, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 130, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11\n    ])), {}).exports;\n} catch (e) {\n    // no wasm support :(\n}\n\n/**\n * Constructs a 64 bit two's-complement integer, given its low and high 32 bit values as *signed* integers.\n *  See the from* functions below for more convenient ways of constructing Longs.\n * @exports Long\n * @class A Long class for representing a 64 bit two's-complement integer value.\n * @param {number} low The low (signed) 32 bits of the long\n * @param {number} high The high (signed) 32 bits of the long\n * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\n * @constructor\n */\nfunction Long(low, high, unsigned) {\n\n    /**\n     * The low 32 bits as a signed value.\n     * @type {number}\n     */\n    this.low = low | 0;\n\n    /**\n     * The high 32 bits as a signed value.\n     * @type {number}\n     */\n    this.high = high | 0;\n\n    /**\n     * Whether unsigned or not.\n     * @type {boolean}\n     */\n    this.unsigned = !!unsigned;\n}\n\n// The internal representation of a long is the two given signed, 32-bit values.\n// We use 32-bit pieces because these are the size of integers on which\n// Javascript performs bit-operations.  For operations like addition and\n// multiplication, we split each number into 16 bit pieces, which can easily be\n// multiplied within Javascript's floating-point representation without overflow\n// or change in sign.\n//\n// In the algorithms below, we frequently reduce the negative case to the\n// positive case by negating the input(s) and then post-processing the result.\n// Note that we must ALWAYS check specially whether those values are MIN_VALUE\n// (-2^63) because -MIN_VALUE == MIN_VALUE (since 2^63 cannot be represented as\n// a positive number, it overflows back into a negative).  Not handling this\n// case would often result in infinite recursion.\n//\n// Common constant values ZERO, ONE, NEG_ONE, etc. are defined below the from*\n// methods on which they depend.\n\n/**\n * An indicator used to reliably determine if an object is a Long or not.\n * @type {boolean}\n * @const\n * @private\n */\nLong.prototype.__isLong__;\n\nObject.defineProperty(Long.prototype, \"__isLong__\", { value: true });\n\n/**\n * @function\n * @param {*} obj Object\n * @returns {boolean}\n * @inner\n */\nfunction isLong(obj) {\n    return (obj && obj[\"__isLong__\"]) === true;\n}\n\n/**\n * Tests if the specified object is a Long.\n * @function\n * @param {*} obj Object\n * @returns {boolean}\n */\nLong.isLong = isLong;\n\n/**\n * A cache of the Long representations of small integer values.\n * @type {!Object}\n * @inner\n */\nvar INT_CACHE = {};\n\n/**\n * A cache of the Long representations of small unsigned integer values.\n * @type {!Object}\n * @inner\n */\nvar UINT_CACHE = {};\n\n/**\n * @param {number} value\n * @param {boolean=} unsigned\n * @returns {!Long}\n * @inner\n */\nfunction fromInt(value, unsigned) {\n    var obj, cachedObj, cache;\n    if (unsigned) {\n        value >>>= 0;\n        if (cache = (0 <= value && value < 256)) {\n            cachedObj = UINT_CACHE[value];\n            if (cachedObj)\n                return cachedObj;\n        }\n        obj = fromBits(value, (value | 0) < 0 ? -1 : 0, true);\n        if (cache)\n            UINT_CACHE[value] = obj;\n        return obj;\n    } else {\n        value |= 0;\n        if (cache = (-128 <= value && value < 128)) {\n            cachedObj = INT_CACHE[value];\n            if (cachedObj)\n                return cachedObj;\n        }\n        obj = fromBits(value, value < 0 ? -1 : 0, false);\n        if (cache)\n            INT_CACHE[value] = obj;\n        return obj;\n    }\n}\n\n/**\n * Returns a Long representing the given 32 bit integer value.\n * @function\n * @param {number} value The 32 bit integer in question\n * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\n * @returns {!Long} The corresponding Long value\n */\nLong.fromInt = fromInt;\n\n/**\n * @param {number} value\n * @param {boolean=} unsigned\n * @returns {!Long}\n * @inner\n */\nfunction fromNumber(value, unsigned) {\n    if (isNaN(value))\n        return unsigned ? UZERO : ZERO;\n    if (unsigned) {\n        if (value < 0)\n            return UZERO;\n        if (value >= TWO_PWR_64_DBL)\n            return MAX_UNSIGNED_VALUE;\n    } else {\n        if (value <= -TWO_PWR_63_DBL)\n            return MIN_VALUE;\n        if (value + 1 >= TWO_PWR_63_DBL)\n            return MAX_VALUE;\n    }\n    if (value < 0)\n        return fromNumber(-value, unsigned).neg();\n    return fromBits((value % TWO_PWR_32_DBL) | 0, (value / TWO_PWR_32_DBL) | 0, unsigned);\n}\n\n/**\n * Returns a Long representing the given value, provided that it is a finite number. Otherwise, zero is returned.\n * @function\n * @param {number} value The number in question\n * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\n * @returns {!Long} The corresponding Long value\n */\nLong.fromNumber = fromNumber;\n\n/**\n * @param {number} lowBits\n * @param {number} highBits\n * @param {boolean=} unsigned\n * @returns {!Long}\n * @inner\n */\nfunction fromBits(lowBits, highBits, unsigned) {\n    return new Long(lowBits, highBits, unsigned);\n}\n\n/**\n * Returns a Long representing the 64 bit integer that comes by concatenating the given low and high bits. Each is\n *  assumed to use 32 bits.\n * @function\n * @param {number} lowBits The low 32 bits\n * @param {number} highBits The high 32 bits\n * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\n * @returns {!Long} The corresponding Long value\n */\nLong.fromBits = fromBits;\n\n/**\n * @function\n * @param {number} base\n * @param {number} exponent\n * @returns {number}\n * @inner\n */\nvar pow_dbl = Math.pow; // Used 4 times (4*8 to 15+4)\n\n/**\n * @param {string} str\n * @param {(boolean|number)=} unsigned\n * @param {number=} radix\n * @returns {!Long}\n * @inner\n */\nfunction fromString(str, unsigned, radix) {\n    if (str.length === 0)\n        throw Error('empty string');\n    if (str === \"NaN\" || str === \"Infinity\" || str === \"+Infinity\" || str === \"-Infinity\")\n        return ZERO;\n    if (typeof unsigned === 'number') {\n        // For goog.math.long compatibility\n        radix = unsigned,\n            unsigned = false;\n    } else {\n        unsigned = !! unsigned;\n    }\n    radix = radix || 10;\n    if (radix < 2 || 36 < radix)\n        throw RangeError('radix');\n\n    var p;\n    if ((p = str.indexOf('-')) > 0)\n        throw Error('interior hyphen');\n    else if (p === 0) {\n        return fromString(str.substring(1), unsigned, radix).neg();\n    }\n\n    // Do several (8) digits each time through the loop, so as to\n    // minimize the calls to the very expensive emulated div.\n    var radixToPower = fromNumber(pow_dbl(radix, 8));\n\n    var result = ZERO;\n    for (var i = 0; i < str.length; i += 8) {\n        var size = Math.min(8, str.length - i),\n            value = parseInt(str.substring(i, i + size), radix);\n        if (size < 8) {\n            var power = fromNumber(pow_dbl(radix, size));\n            result = result.mul(power).add(fromNumber(value));\n        } else {\n            result = result.mul(radixToPower);\n            result = result.add(fromNumber(value));\n        }\n    }\n    result.unsigned = unsigned;\n    return result;\n}\n\n/**\n * Returns a Long representation of the given string, written using the specified radix.\n * @function\n * @param {string} str The textual representation of the Long\n * @param {(boolean|number)=} unsigned Whether unsigned or not, defaults to signed\n * @param {number=} radix The radix in which the text is written (2-36), defaults to 10\n * @returns {!Long} The corresponding Long value\n */\nLong.fromString = fromString;\n\n/**\n * @function\n * @param {!Long|number|string|!{low: number, high: number, unsigned: boolean}} val\n * @param {boolean=} unsigned\n * @returns {!Long}\n * @inner\n */\nfunction fromValue(val, unsigned) {\n    if (typeof val === 'number')\n        return fromNumber(val, unsigned);\n    if (typeof val === 'string')\n        return fromString(val, unsigned);\n    // Throws for non-objects, converts non-instanceof Long:\n    return fromBits(val.low, val.high, typeof unsigned === 'boolean' ? unsigned : val.unsigned);\n}\n\n/**\n * Converts the specified value to a Long using the appropriate from* function for its type.\n * @function\n * @param {!Long|number|string|!{low: number, high: number, unsigned: boolean}} val Value\n * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\n * @returns {!Long}\n */\nLong.fromValue = fromValue;\n\n// NOTE: the compiler should inline these constant values below and then remove these variables, so there should be\n// no runtime penalty for these.\n\n/**\n * @type {number}\n * @const\n * @inner\n */\nvar TWO_PWR_16_DBL = 1 << 16;\n\n/**\n * @type {number}\n * @const\n * @inner\n */\nvar TWO_PWR_24_DBL = 1 << 24;\n\n/**\n * @type {number}\n * @const\n * @inner\n */\nvar TWO_PWR_32_DBL = TWO_PWR_16_DBL * TWO_PWR_16_DBL;\n\n/**\n * @type {number}\n * @const\n * @inner\n */\nvar TWO_PWR_64_DBL = TWO_PWR_32_DBL * TWO_PWR_32_DBL;\n\n/**\n * @type {number}\n * @const\n * @inner\n */\nvar TWO_PWR_63_DBL = TWO_PWR_64_DBL / 2;\n\n/**\n * @type {!Long}\n * @const\n * @inner\n */\nvar TWO_PWR_24 = fromInt(TWO_PWR_24_DBL);\n\n/**\n * @type {!Long}\n * @inner\n */\nvar ZERO = fromInt(0);\n\n/**\n * Signed zero.\n * @type {!Long}\n */\nLong.ZERO = ZERO;\n\n/**\n * @type {!Long}\n * @inner\n */\nvar UZERO = fromInt(0, true);\n\n/**\n * Unsigned zero.\n * @type {!Long}\n */\nLong.UZERO = UZERO;\n\n/**\n * @type {!Long}\n * @inner\n */\nvar ONE = fromInt(1);\n\n/**\n * Signed one.\n * @type {!Long}\n */\nLong.ONE = ONE;\n\n/**\n * @type {!Long}\n * @inner\n */\nvar UONE = fromInt(1, true);\n\n/**\n * Unsigned one.\n * @type {!Long}\n */\nLong.UONE = UONE;\n\n/**\n * @type {!Long}\n * @inner\n */\nvar NEG_ONE = fromInt(-1);\n\n/**\n * Signed negative one.\n * @type {!Long}\n */\nLong.NEG_ONE = NEG_ONE;\n\n/**\n * @type {!Long}\n * @inner\n */\nvar MAX_VALUE = fromBits(0xFFFFFFFF|0, 0x7FFFFFFF|0, false);\n\n/**\n * Maximum signed value.\n * @type {!Long}\n */\nLong.MAX_VALUE = MAX_VALUE;\n\n/**\n * @type {!Long}\n * @inner\n */\nvar MAX_UNSIGNED_VALUE = fromBits(0xFFFFFFFF|0, 0xFFFFFFFF|0, true);\n\n/**\n * Maximum unsigned value.\n * @type {!Long}\n */\nLong.MAX_UNSIGNED_VALUE = MAX_UNSIGNED_VALUE;\n\n/**\n * @type {!Long}\n * @inner\n */\nvar MIN_VALUE = fromBits(0, 0x80000000|0, false);\n\n/**\n * Minimum signed value.\n * @type {!Long}\n */\nLong.MIN_VALUE = MIN_VALUE;\n\n/**\n * @alias Long.prototype\n * @inner\n */\nvar LongPrototype = Long.prototype;\n\n/**\n * Converts the Long to a 32 bit integer, assuming it is a 32 bit integer.\n * @returns {number}\n */\nLongPrototype.toInt = function toInt() {\n    return this.unsigned ? this.low >>> 0 : this.low;\n};\n\n/**\n * Converts the Long to a the nearest floating-point representation of this value (double, 53 bit mantissa).\n * @returns {number}\n */\nLongPrototype.toNumber = function toNumber() {\n    if (this.unsigned)\n        return ((this.high >>> 0) * TWO_PWR_32_DBL) + (this.low >>> 0);\n    return this.high * TWO_PWR_32_DBL + (this.low >>> 0);\n};\n\n/**\n * Converts the Long to a string written in the specified radix.\n * @param {number=} radix Radix (2-36), defaults to 10\n * @returns {string}\n * @override\n * @throws {RangeError} If `radix` is out of range\n */\nLongPrototype.toString = function toString(radix) {\n    radix = radix || 10;\n    if (radix < 2 || 36 < radix)\n        throw RangeError('radix');\n    if (this.isZero())\n        return '0';\n    if (this.isNegative()) { // Unsigned Longs are never negative\n        if (this.eq(MIN_VALUE)) {\n            // We need to change the Long value before it can be negated, so we remove\n            // the bottom-most digit in this base and then recurse to do the rest.\n            var radixLong = fromNumber(radix),\n                div = this.div(radixLong),\n                rem1 = div.mul(radixLong).sub(this);\n            return div.toString(radix) + rem1.toInt().toString(radix);\n        } else\n            return '-' + this.neg().toString(radix);\n    }\n\n    // Do several (6) digits each time through the loop, so as to\n    // minimize the calls to the very expensive emulated div.\n    var radixToPower = fromNumber(pow_dbl(radix, 6), this.unsigned),\n        rem = this;\n    var result = '';\n    while (true) {\n        var remDiv = rem.div(radixToPower),\n            intval = rem.sub(remDiv.mul(radixToPower)).toInt() >>> 0,\n            digits = intval.toString(radix);\n        rem = remDiv;\n        if (rem.isZero())\n            return digits + result;\n        else {\n            while (digits.length < 6)\n                digits = '0' + digits;\n            result = '' + digits + result;\n        }\n    }\n};\n\n/**\n * Gets the high 32 bits as a signed integer.\n * @returns {number} Signed high bits\n */\nLongPrototype.getHighBits = function getHighBits() {\n    return this.high;\n};\n\n/**\n * Gets the high 32 bits as an unsigned integer.\n * @returns {number} Unsigned high bits\n */\nLongPrototype.getHighBitsUnsigned = function getHighBitsUnsigned() {\n    return this.high >>> 0;\n};\n\n/**\n * Gets the low 32 bits as a signed integer.\n * @returns {number} Signed low bits\n */\nLongPrototype.getLowBits = function getLowBits() {\n    return this.low;\n};\n\n/**\n * Gets the low 32 bits as an unsigned integer.\n * @returns {number} Unsigned low bits\n */\nLongPrototype.getLowBitsUnsigned = function getLowBitsUnsigned() {\n    return this.low >>> 0;\n};\n\n/**\n * Gets the number of bits needed to represent the absolute value of this Long.\n * @returns {number}\n */\nLongPrototype.getNumBitsAbs = function getNumBitsAbs() {\n    if (this.isNegative()) // Unsigned Longs are never negative\n        return this.eq(MIN_VALUE) ? 64 : this.neg().getNumBitsAbs();\n    var val = this.high != 0 ? this.high : this.low;\n    for (var bit = 31; bit > 0; bit--)\n        if ((val & (1 << bit)) != 0)\n            break;\n    return this.high != 0 ? bit + 33 : bit + 1;\n};\n\n/**\n * Tests if this Long's value equals zero.\n * @returns {boolean}\n */\nLongPrototype.isZero = function isZero() {\n    return this.high === 0 && this.low === 0;\n};\n\n/**\n * Tests if this Long's value equals zero. This is an alias of {@link Long#isZero}.\n * @returns {boolean}\n */\nLongPrototype.eqz = LongPrototype.isZero;\n\n/**\n * Tests if this Long's value is negative.\n * @returns {boolean}\n */\nLongPrototype.isNegative = function isNegative() {\n    return !this.unsigned && this.high < 0;\n};\n\n/**\n * Tests if this Long's value is positive.\n * @returns {boolean}\n */\nLongPrototype.isPositive = function isPositive() {\n    return this.unsigned || this.high >= 0;\n};\n\n/**\n * Tests if this Long's value is odd.\n * @returns {boolean}\n */\nLongPrototype.isOdd = function isOdd() {\n    return (this.low & 1) === 1;\n};\n\n/**\n * Tests if this Long's value is even.\n * @returns {boolean}\n */\nLongPrototype.isEven = function isEven() {\n    return (this.low & 1) === 0;\n};\n\n/**\n * Tests if this Long's value equals the specified's.\n * @param {!Long|number|string} other Other value\n * @returns {boolean}\n */\nLongPrototype.equals = function equals(other) {\n    if (!isLong(other))\n        other = fromValue(other);\n    if (this.unsigned !== other.unsigned && (this.high >>> 31) === 1 && (other.high >>> 31) === 1)\n        return false;\n    return this.high === other.high && this.low === other.low;\n};\n\n/**\n * Tests if this Long's value equals the specified's. This is an alias of {@link Long#equals}.\n * @function\n * @param {!Long|number|string} other Other value\n * @returns {boolean}\n */\nLongPrototype.eq = LongPrototype.equals;\n\n/**\n * Tests if this Long's value differs from the specified's.\n * @param {!Long|number|string} other Other value\n * @returns {boolean}\n */\nLongPrototype.notEquals = function notEquals(other) {\n    return !this.eq(/* validates */ other);\n};\n\n/**\n * Tests if this Long's value differs from the specified's. This is an alias of {@link Long#notEquals}.\n * @function\n * @param {!Long|number|string} other Other value\n * @returns {boolean}\n */\nLongPrototype.neq = LongPrototype.notEquals;\n\n/**\n * Tests if this Long's value differs from the specified's. This is an alias of {@link Long#notEquals}.\n * @function\n * @param {!Long|number|string} other Other value\n * @returns {boolean}\n */\nLongPrototype.ne = LongPrototype.notEquals;\n\n/**\n * Tests if this Long's value is less than the specified's.\n * @param {!Long|number|string} other Other value\n * @returns {boolean}\n */\nLongPrototype.lessThan = function lessThan(other) {\n    return this.comp(/* validates */ other) < 0;\n};\n\n/**\n * Tests if this Long's value is less than the specified's. This is an alias of {@link Long#lessThan}.\n * @function\n * @param {!Long|number|string} other Other value\n * @returns {boolean}\n */\nLongPrototype.lt = LongPrototype.lessThan;\n\n/**\n * Tests if this Long's value is less than or equal the specified's.\n * @param {!Long|number|string} other Other value\n * @returns {boolean}\n */\nLongPrototype.lessThanOrEqual = function lessThanOrEqual(other) {\n    return this.comp(/* validates */ other) <= 0;\n};\n\n/**\n * Tests if this Long's value is less than or equal the specified's. This is an alias of {@link Long#lessThanOrEqual}.\n * @function\n * @param {!Long|number|string} other Other value\n * @returns {boolean}\n */\nLongPrototype.lte = LongPrototype.lessThanOrEqual;\n\n/**\n * Tests if this Long's value is less than or equal the specified's. This is an alias of {@link Long#lessThanOrEqual}.\n * @function\n * @param {!Long|number|string} other Other value\n * @returns {boolean}\n */\nLongPrototype.le = LongPrototype.lessThanOrEqual;\n\n/**\n * Tests if this Long's value is greater than the specified's.\n * @param {!Long|number|string} other Other value\n * @returns {boolean}\n */\nLongPrototype.greaterThan = function greaterThan(other) {\n    return this.comp(/* validates */ other) > 0;\n};\n\n/**\n * Tests if this Long's value is greater than the specified's. This is an alias of {@link Long#greaterThan}.\n * @function\n * @param {!Long|number|string} other Other value\n * @returns {boolean}\n */\nLongPrototype.gt = LongPrototype.greaterThan;\n\n/**\n * Tests if this Long's value is greater than or equal the specified's.\n * @param {!Long|number|string} other Other value\n * @returns {boolean}\n */\nLongPrototype.greaterThanOrEqual = function greaterThanOrEqual(other) {\n    return this.comp(/* validates */ other) >= 0;\n};\n\n/**\n * Tests if this Long's value is greater than or equal the specified's. This is an alias of {@link Long#greaterThanOrEqual}.\n * @function\n * @param {!Long|number|string} other Other value\n * @returns {boolean}\n */\nLongPrototype.gte = LongPrototype.greaterThanOrEqual;\n\n/**\n * Tests if this Long's value is greater than or equal the specified's. This is an alias of {@link Long#greaterThanOrEqual}.\n * @function\n * @param {!Long|number|string} other Other value\n * @returns {boolean}\n */\nLongPrototype.ge = LongPrototype.greaterThanOrEqual;\n\n/**\n * Compares this Long's value with the specified's.\n * @param {!Long|number|string} other Other value\n * @returns {number} 0 if they are the same, 1 if the this is greater and -1\n *  if the given one is greater\n */\nLongPrototype.compare = function compare(other) {\n    if (!isLong(other))\n        other = fromValue(other);\n    if (this.eq(other))\n        return 0;\n    var thisNeg = this.isNegative(),\n        otherNeg = other.isNegative();\n    if (thisNeg && !otherNeg)\n        return -1;\n    if (!thisNeg && otherNeg)\n        return 1;\n    // At this point the sign bits are the same\n    if (!this.unsigned)\n        return this.sub(other).isNegative() ? -1 : 1;\n    // Both are positive if at least one is unsigned\n    return (other.high >>> 0) > (this.high >>> 0) || (other.high === this.high && (other.low >>> 0) > (this.low >>> 0)) ? -1 : 1;\n};\n\n/**\n * Compares this Long's value with the specified's. This is an alias of {@link Long#compare}.\n * @function\n * @param {!Long|number|string} other Other value\n * @returns {number} 0 if they are the same, 1 if the this is greater and -1\n *  if the given one is greater\n */\nLongPrototype.comp = LongPrototype.compare;\n\n/**\n * Negates this Long's value.\n * @returns {!Long} Negated Long\n */\nLongPrototype.negate = function negate() {\n    if (!this.unsigned && this.eq(MIN_VALUE))\n        return MIN_VALUE;\n    return this.not().add(ONE);\n};\n\n/**\n * Negates this Long's value. This is an alias of {@link Long#negate}.\n * @function\n * @returns {!Long} Negated Long\n */\nLongPrototype.neg = LongPrototype.negate;\n\n/**\n * Returns the sum of this and the specified Long.\n * @param {!Long|number|string} addend Addend\n * @returns {!Long} Sum\n */\nLongPrototype.add = function add(addend) {\n    if (!isLong(addend))\n        addend = fromValue(addend);\n\n    // Divide each number into 4 chunks of 16 bits, and then sum the chunks.\n\n    var a48 = this.high >>> 16;\n    var a32 = this.high & 0xFFFF;\n    var a16 = this.low >>> 16;\n    var a00 = this.low & 0xFFFF;\n\n    var b48 = addend.high >>> 16;\n    var b32 = addend.high & 0xFFFF;\n    var b16 = addend.low >>> 16;\n    var b00 = addend.low & 0xFFFF;\n\n    var c48 = 0, c32 = 0, c16 = 0, c00 = 0;\n    c00 += a00 + b00;\n    c16 += c00 >>> 16;\n    c00 &= 0xFFFF;\n    c16 += a16 + b16;\n    c32 += c16 >>> 16;\n    c16 &= 0xFFFF;\n    c32 += a32 + b32;\n    c48 += c32 >>> 16;\n    c32 &= 0xFFFF;\n    c48 += a48 + b48;\n    c48 &= 0xFFFF;\n    return fromBits((c16 << 16) | c00, (c48 << 16) | c32, this.unsigned);\n};\n\n/**\n * Returns the difference of this and the specified Long.\n * @param {!Long|number|string} subtrahend Subtrahend\n * @returns {!Long} Difference\n */\nLongPrototype.subtract = function subtract(subtrahend) {\n    if (!isLong(subtrahend))\n        subtrahend = fromValue(subtrahend);\n    return this.add(subtrahend.neg());\n};\n\n/**\n * Returns the difference of this and the specified Long. This is an alias of {@link Long#subtract}.\n * @function\n * @param {!Long|number|string} subtrahend Subtrahend\n * @returns {!Long} Difference\n */\nLongPrototype.sub = LongPrototype.subtract;\n\n/**\n * Returns the product of this and the specified Long.\n * @param {!Long|number|string} multiplier Multiplier\n * @returns {!Long} Product\n */\nLongPrototype.multiply = function multiply(multiplier) {\n    if (this.isZero())\n        return ZERO;\n    if (!isLong(multiplier))\n        multiplier = fromValue(multiplier);\n\n    // use wasm support if present\n    if (wasm) {\n        var low = wasm.mul(this.low,\n            this.high,\n            multiplier.low,\n            multiplier.high);\n        return fromBits(low, wasm.get_high(), this.unsigned);\n    }\n\n    if (multiplier.isZero())\n        return ZERO;\n    if (this.eq(MIN_VALUE))\n        return multiplier.isOdd() ? MIN_VALUE : ZERO;\n    if (multiplier.eq(MIN_VALUE))\n        return this.isOdd() ? MIN_VALUE : ZERO;\n\n    if (this.isNegative()) {\n        if (multiplier.isNegative())\n            return this.neg().mul(multiplier.neg());\n        else\n            return this.neg().mul(multiplier).neg();\n    } else if (multiplier.isNegative())\n        return this.mul(multiplier.neg()).neg();\n\n    // If both longs are small, use float multiplication\n    if (this.lt(TWO_PWR_24) && multiplier.lt(TWO_PWR_24))\n        return fromNumber(this.toNumber() * multiplier.toNumber(), this.unsigned);\n\n    // Divide each long into 4 chunks of 16 bits, and then add up 4x4 products.\n    // We can skip products that would overflow.\n\n    var a48 = this.high >>> 16;\n    var a32 = this.high & 0xFFFF;\n    var a16 = this.low >>> 16;\n    var a00 = this.low & 0xFFFF;\n\n    var b48 = multiplier.high >>> 16;\n    var b32 = multiplier.high & 0xFFFF;\n    var b16 = multiplier.low >>> 16;\n    var b00 = multiplier.low & 0xFFFF;\n\n    var c48 = 0, c32 = 0, c16 = 0, c00 = 0;\n    c00 += a00 * b00;\n    c16 += c00 >>> 16;\n    c00 &= 0xFFFF;\n    c16 += a16 * b00;\n    c32 += c16 >>> 16;\n    c16 &= 0xFFFF;\n    c16 += a00 * b16;\n    c32 += c16 >>> 16;\n    c16 &= 0xFFFF;\n    c32 += a32 * b00;\n    c48 += c32 >>> 16;\n    c32 &= 0xFFFF;\n    c32 += a16 * b16;\n    c48 += c32 >>> 16;\n    c32 &= 0xFFFF;\n    c32 += a00 * b32;\n    c48 += c32 >>> 16;\n    c32 &= 0xFFFF;\n    c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;\n    c48 &= 0xFFFF;\n    return fromBits((c16 << 16) | c00, (c48 << 16) | c32, this.unsigned);\n};\n\n/**\n * Returns the product of this and the specified Long. This is an alias of {@link Long#multiply}.\n * @function\n * @param {!Long|number|string} multiplier Multiplier\n * @returns {!Long} Product\n */\nLongPrototype.mul = LongPrototype.multiply;\n\n/**\n * Returns this Long divided by the specified. The result is signed if this Long is signed or\n *  unsigned if this Long is unsigned.\n * @param {!Long|number|string} divisor Divisor\n * @returns {!Long} Quotient\n */\nLongPrototype.divide = function divide(divisor) {\n    if (!isLong(divisor))\n        divisor = fromValue(divisor);\n    if (divisor.isZero())\n        throw Error('division by zero');\n\n    // use wasm support if present\n    if (wasm) {\n        // guard against signed division overflow: the largest\n        // negative number / -1 would be 1 larger than the largest\n        // positive number, due to two's complement.\n        if (!this.unsigned &&\n            this.high === -0x80000000 &&\n            divisor.low === -1 && divisor.high === -1) {\n            // be consistent with non-wasm code path\n            return this;\n        }\n        var low = (this.unsigned ? wasm.div_u : wasm.div_s)(\n            this.low,\n            this.high,\n            divisor.low,\n            divisor.high\n        );\n        return fromBits(low, wasm.get_high(), this.unsigned);\n    }\n\n    if (this.isZero())\n        return this.unsigned ? UZERO : ZERO;\n    var approx, rem, res;\n    if (!this.unsigned) {\n        // This section is only relevant for signed longs and is derived from the\n        // closure library as a whole.\n        if (this.eq(MIN_VALUE)) {\n            if (divisor.eq(ONE) || divisor.eq(NEG_ONE))\n                return MIN_VALUE;  // recall that -MIN_VALUE == MIN_VALUE\n            else if (divisor.eq(MIN_VALUE))\n                return ONE;\n            else {\n                // At this point, we have |other| >= 2, so |this/other| < |MIN_VALUE|.\n                var halfThis = this.shr(1);\n                approx = halfThis.div(divisor).shl(1);\n                if (approx.eq(ZERO)) {\n                    return divisor.isNegative() ? ONE : NEG_ONE;\n                } else {\n                    rem = this.sub(divisor.mul(approx));\n                    res = approx.add(rem.div(divisor));\n                    return res;\n                }\n            }\n        } else if (divisor.eq(MIN_VALUE))\n            return this.unsigned ? UZERO : ZERO;\n        if (this.isNegative()) {\n            if (divisor.isNegative())\n                return this.neg().div(divisor.neg());\n            return this.neg().div(divisor).neg();\n        } else if (divisor.isNegative())\n            return this.div(divisor.neg()).neg();\n        res = ZERO;\n    } else {\n        // The algorithm below has not been made for unsigned longs. It's therefore\n        // required to take special care of the MSB prior to running it.\n        if (!divisor.unsigned)\n            divisor = divisor.toUnsigned();\n        if (divisor.gt(this))\n            return UZERO;\n        if (divisor.gt(this.shru(1))) // 15 >>> 1 = 7 ; with divisor = 8 ; true\n            return UONE;\n        res = UZERO;\n    }\n\n    // Repeat the following until the remainder is less than other:  find a\n    // floating-point that approximates remainder / other *from below*, add this\n    // into the result, and subtract it from the remainder.  It is critical that\n    // the approximate value is less than or equal to the real value so that the\n    // remainder never becomes negative.\n    rem = this;\n    while (rem.gte(divisor)) {\n        // Approximate the result of division. This may be a little greater or\n        // smaller than the actual value.\n        approx = Math.max(1, Math.floor(rem.toNumber() / divisor.toNumber()));\n\n        // We will tweak the approximate result by changing it in the 48-th digit or\n        // the smallest non-fractional digit, whichever is larger.\n        var log2 = Math.ceil(Math.log(approx) / Math.LN2),\n            delta = (log2 <= 48) ? 1 : pow_dbl(2, log2 - 48),\n\n        // Decrease the approximation until it is smaller than the remainder.  Note\n        // that if it is too large, the product overflows and is negative.\n            approxRes = fromNumber(approx),\n            approxRem = approxRes.mul(divisor);\n        while (approxRem.isNegative() || approxRem.gt(rem)) {\n            approx -= delta;\n            approxRes = fromNumber(approx, this.unsigned);\n            approxRem = approxRes.mul(divisor);\n        }\n\n        // We know the answer can't be zero... and actually, zero would cause\n        // infinite recursion since we would make no progress.\n        if (approxRes.isZero())\n            approxRes = ONE;\n\n        res = res.add(approxRes);\n        rem = rem.sub(approxRem);\n    }\n    return res;\n};\n\n/**\n * Returns this Long divided by the specified. This is an alias of {@link Long#divide}.\n * @function\n * @param {!Long|number|string} divisor Divisor\n * @returns {!Long} Quotient\n */\nLongPrototype.div = LongPrototype.divide;\n\n/**\n * Returns this Long modulo the specified.\n * @param {!Long|number|string} divisor Divisor\n * @returns {!Long} Remainder\n */\nLongPrototype.modulo = function modulo(divisor) {\n    if (!isLong(divisor))\n        divisor = fromValue(divisor);\n\n    // use wasm support if present\n    if (wasm) {\n        var low = (this.unsigned ? wasm.rem_u : wasm.rem_s)(\n            this.low,\n            this.high,\n            divisor.low,\n            divisor.high\n        );\n        return fromBits(low, wasm.get_high(), this.unsigned);\n    }\n\n    return this.sub(this.div(divisor).mul(divisor));\n};\n\n/**\n * Returns this Long modulo the specified. This is an alias of {@link Long#modulo}.\n * @function\n * @param {!Long|number|string} divisor Divisor\n * @returns {!Long} Remainder\n */\nLongPrototype.mod = LongPrototype.modulo;\n\n/**\n * Returns this Long modulo the specified. This is an alias of {@link Long#modulo}.\n * @function\n * @param {!Long|number|string} divisor Divisor\n * @returns {!Long} Remainder\n */\nLongPrototype.rem = LongPrototype.modulo;\n\n/**\n * Returns the bitwise NOT of this Long.\n * @returns {!Long}\n */\nLongPrototype.not = function not() {\n    return fromBits(~this.low, ~this.high, this.unsigned);\n};\n\n/**\n * Returns the bitwise AND of this Long and the specified.\n * @param {!Long|number|string} other Other Long\n * @returns {!Long}\n */\nLongPrototype.and = function and(other) {\n    if (!isLong(other))\n        other = fromValue(other);\n    return fromBits(this.low & other.low, this.high & other.high, this.unsigned);\n};\n\n/**\n * Returns the bitwise OR of this Long and the specified.\n * @param {!Long|number|string} other Other Long\n * @returns {!Long}\n */\nLongPrototype.or = function or(other) {\n    if (!isLong(other))\n        other = fromValue(other);\n    return fromBits(this.low | other.low, this.high | other.high, this.unsigned);\n};\n\n/**\n * Returns the bitwise XOR of this Long and the given one.\n * @param {!Long|number|string} other Other Long\n * @returns {!Long}\n */\nLongPrototype.xor = function xor(other) {\n    if (!isLong(other))\n        other = fromValue(other);\n    return fromBits(this.low ^ other.low, this.high ^ other.high, this.unsigned);\n};\n\n/**\n * Returns this Long with bits shifted to the left by the given amount.\n * @param {number|!Long} numBits Number of bits\n * @returns {!Long} Shifted Long\n */\nLongPrototype.shiftLeft = function shiftLeft(numBits) {\n    if (isLong(numBits))\n        numBits = numBits.toInt();\n    if ((numBits &= 63) === 0)\n        return this;\n    else if (numBits < 32)\n        return fromBits(this.low << numBits, (this.high << numBits) | (this.low >>> (32 - numBits)), this.unsigned);\n    else\n        return fromBits(0, this.low << (numBits - 32), this.unsigned);\n};\n\n/**\n * Returns this Long with bits shifted to the left by the given amount. This is an alias of {@link Long#shiftLeft}.\n * @function\n * @param {number|!Long} numBits Number of bits\n * @returns {!Long} Shifted Long\n */\nLongPrototype.shl = LongPrototype.shiftLeft;\n\n/**\n * Returns this Long with bits arithmetically shifted to the right by the given amount.\n * @param {number|!Long} numBits Number of bits\n * @returns {!Long} Shifted Long\n */\nLongPrototype.shiftRight = function shiftRight(numBits) {\n    if (isLong(numBits))\n        numBits = numBits.toInt();\n    if ((numBits &= 63) === 0)\n        return this;\n    else if (numBits < 32)\n        return fromBits((this.low >>> numBits) | (this.high << (32 - numBits)), this.high >> numBits, this.unsigned);\n    else\n        return fromBits(this.high >> (numBits - 32), this.high >= 0 ? 0 : -1, this.unsigned);\n};\n\n/**\n * Returns this Long with bits arithmetically shifted to the right by the given amount. This is an alias of {@link Long#shiftRight}.\n * @function\n * @param {number|!Long} numBits Number of bits\n * @returns {!Long} Shifted Long\n */\nLongPrototype.shr = LongPrototype.shiftRight;\n\n/**\n * Returns this Long with bits logically shifted to the right by the given amount.\n * @param {number|!Long} numBits Number of bits\n * @returns {!Long} Shifted Long\n */\nLongPrototype.shiftRightUnsigned = function shiftRightUnsigned(numBits) {\n    if (isLong(numBits))\n        numBits = numBits.toInt();\n    numBits &= 63;\n    if (numBits === 0)\n        return this;\n    else {\n        var high = this.high;\n        if (numBits < 32) {\n            var low = this.low;\n            return fromBits((low >>> numBits) | (high << (32 - numBits)), high >>> numBits, this.unsigned);\n        } else if (numBits === 32)\n            return fromBits(high, 0, this.unsigned);\n        else\n            return fromBits(high >>> (numBits - 32), 0, this.unsigned);\n    }\n};\n\n/**\n * Returns this Long with bits logically shifted to the right by the given amount. This is an alias of {@link Long#shiftRightUnsigned}.\n * @function\n * @param {number|!Long} numBits Number of bits\n * @returns {!Long} Shifted Long\n */\nLongPrototype.shru = LongPrototype.shiftRightUnsigned;\n\n/**\n * Returns this Long with bits logically shifted to the right by the given amount. This is an alias of {@link Long#shiftRightUnsigned}.\n * @function\n * @param {number|!Long} numBits Number of bits\n * @returns {!Long} Shifted Long\n */\nLongPrototype.shr_u = LongPrototype.shiftRightUnsigned;\n\n/**\n * Converts this Long to signed.\n * @returns {!Long} Signed long\n */\nLongPrototype.toSigned = function toSigned() {\n    if (!this.unsigned)\n        return this;\n    return fromBits(this.low, this.high, false);\n};\n\n/**\n * Converts this Long to unsigned.\n * @returns {!Long} Unsigned long\n */\nLongPrototype.toUnsigned = function toUnsigned() {\n    if (this.unsigned)\n        return this;\n    return fromBits(this.low, this.high, true);\n};\n\n/**\n * Converts this Long to its byte representation.\n * @param {boolean=} le Whether little or big endian, defaults to big endian\n * @returns {!Array.<number>} Byte representation\n */\nLongPrototype.toBytes = function toBytes(le) {\n    return le ? this.toBytesLE() : this.toBytesBE();\n};\n\n/**\n * Converts this Long to its little endian byte representation.\n * @returns {!Array.<number>} Little endian byte representation\n */\nLongPrototype.toBytesLE = function toBytesLE() {\n    var hi = this.high,\n        lo = this.low;\n    return [\n        lo        & 0xff,\n        lo >>>  8 & 0xff,\n        lo >>> 16 & 0xff,\n        lo >>> 24       ,\n        hi        & 0xff,\n        hi >>>  8 & 0xff,\n        hi >>> 16 & 0xff,\n        hi >>> 24\n    ];\n};\n\n/**\n * Converts this Long to its big endian byte representation.\n * @returns {!Array.<number>} Big endian byte representation\n */\nLongPrototype.toBytesBE = function toBytesBE() {\n    var hi = this.high,\n        lo = this.low;\n    return [\n        hi >>> 24       ,\n        hi >>> 16 & 0xff,\n        hi >>>  8 & 0xff,\n        hi        & 0xff,\n        lo >>> 24       ,\n        lo >>> 16 & 0xff,\n        lo >>>  8 & 0xff,\n        lo        & 0xff\n    ];\n};\n\n/**\n * Creates a Long from its byte representation.\n * @param {!Array.<number>} bytes Byte representation\n * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\n * @param {boolean=} le Whether little or big endian, defaults to big endian\n * @returns {Long} The corresponding Long value\n */\nLong.fromBytes = function fromBytes(bytes, unsigned, le) {\n    return le ? Long.fromBytesLE(bytes, unsigned) : Long.fromBytesBE(bytes, unsigned);\n};\n\n/**\n * Creates a Long from its little endian byte representation.\n * @param {!Array.<number>} bytes Little endian byte representation\n * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\n * @returns {Long} The corresponding Long value\n */\nLong.fromBytesLE = function fromBytesLE(bytes, unsigned) {\n    return new Long(\n        bytes[0]       |\n        bytes[1] <<  8 |\n        bytes[2] << 16 |\n        bytes[3] << 24,\n        bytes[4]       |\n        bytes[5] <<  8 |\n        bytes[6] << 16 |\n        bytes[7] << 24,\n        unsigned\n    );\n};\n\n/**\n * Creates a Long from its big endian byte representation.\n * @param {!Array.<number>} bytes Big endian byte representation\n * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\n * @returns {Long} The corresponding Long value\n */\nLong.fromBytesBE = function fromBytesBE(bytes, unsigned) {\n    return new Long(\n        bytes[4] << 24 |\n        bytes[5] << 16 |\n        bytes[6] <<  8 |\n        bytes[7],\n        bytes[0] << 24 |\n        bytes[1] << 16 |\n        bytes[2] <<  8 |\n        bytes[3],\n        unsigned\n    );\n};","module.exports = LongBits;\n\nfunction LongBits(lo, hi) {\n    this.lo = lo >>> 0;\n    this.hi = hi >>> 0;\n}\n\nvar zero = LongBits.zero = new LongBits(0, 0);\n\nzero.toNumber = function() { return 0; };\nzero.zzEncode = zero.zzDecode = function() { return this; };\nzero.length = function() { return 1; };\n\n\nvar zeroHash = LongBits.zeroHash = \"\\0\\0\\0\\0\\0\\0\\0\\0\";\n\nLongBits.fromNumber = function fromNumber(value) {\n    if (value === 0)\n        return zero;\n    var sign = value < 0;//sign 1 ,\n    if (sign)\n        value = -value;\n    var lo = value >>> 0,//32\n        hi = (value - lo) / 4294967296 >>> 0; //32\n    if (sign) { //\n        hi = ~hi >>> 0; //32\n        lo = ~lo >>> 0; //32\n        if (++lo > 4294967295) { //32Math.pow(2,31)-1\n            lo = 0;\n            if (++hi > 4294967295) //32Math.pow(2,31)-1\n                hi = 0;\n        }\n    }\n    return new LongBits(lo, hi);\n};\n\n\nLongBits.from = function from(value) {\n    if (typeof value === \"number\")\n        return LongBits.fromNumber(value);\n    if (typeof value === \"string\" || value instanceof String) {\n        return LongBits.fromNumber(parseInt(value, 10));\n    }\n    return value.low || value.high ? new LongBits(value.low >>> 0, value.high >>> 0) : zero;\n};\n\nLongBits.prototype.toNumber = function toNumber(unsigned) {\n    if (!unsigned && this.hi >>> 31) {\n        var lo = ~this.lo + 1 >>> 0,\n            hi = ~this.hi     >>> 0;\n        if (!lo)\n            hi = hi + 1 >>> 0;\n        return -(lo + hi * 4294967296);\n    }\n    return this.lo + this.hi * 4294967296;\n};\nLongBits.prototype.toLong = function toLong(unsigned) {\n    //return util.Long\n    //    ? new util.Long(this.lo | 0, this.hi | 0, Boolean(unsigned))\n    //    /* istanbul ignore next */\n    //    : { low: this.lo | 0, high: this.hi | 0, unsigned: Boolean(unsigned) };\n    return { low: this.lo | 0, high: this.hi | 0, unsigned: Boolean(unsigned) };\n};\n\nvar charCodeAt = String.prototype.charCodeAt;\n\nLongBits.fromHash = function fromHash(hash) {\n    if (hash === zeroHash)\n        return zero;\n    return new LongBits(\n        ( charCodeAt.call(hash, 0)\n        | charCodeAt.call(hash, 1) << 8\n        | charCodeAt.call(hash, 2) << 16\n        | charCodeAt.call(hash, 3) << 24) >>> 0\n        ,\n        ( charCodeAt.call(hash, 4)\n        | charCodeAt.call(hash, 5) << 8\n        | charCodeAt.call(hash, 6) << 16\n        | charCodeAt.call(hash, 7) << 24) >>> 0\n    );\n};\n\nLongBits.prototype.toHash = function toHash() {\n    return String.fromCharCode(\n        this.lo        & 255,\n        this.lo >>> 8  & 255,\n        this.lo >>> 16 & 255,\n        this.lo >>> 24      ,\n        this.hi        & 255,\n        this.hi >>> 8  & 255,\n        this.hi >>> 16 & 255,\n        this.hi >>> 24\n    );\n};\n\nLongBits.prototype.zzEncode = function zzEncode() {\n    var mask =   this.hi >> 31;\n    this.hi  = ((this.hi << 1 | this.lo >>> 31) ^ mask) >>> 0;\n    this.lo  = ( this.lo << 1                   ^ mask) >>> 0;\n    return this;\n};\n\nLongBits.prototype.zzDecode = function zzDecode() {\n    var mask = -(this.lo & 1);\n    this.lo  = ((this.lo >>> 1 | this.hi << 31) ^ mask) >>> 0;\n    this.hi  = ( this.hi >>> 1                  ^ mask) >>> 0;\n    return this;\n};\nLongBits.prototype.length = function length() {\n    var part0 =  this.lo,\n        part1 = (this.lo >>> 28 | this.hi << 4) >>> 0,\n        part2 =  this.hi >>> 24;\n    return part2 === 0\n        ? part1 === 0\n        ? part0 < 16384\n        ? part0 < 128 ? 1 : 2\n        : part0 < 2097152 ? 3 : 4\n        : part1 < 16384\n        ? part1 < 128 ? 5 : 6\n        : part1 < 2097152 ? 7 : 8\n        : part2 < 128 ? 9 : 10;\n};\n","module.exports = MapField;\n\n// extends Field\nvar Field = require(10);\n((MapField.prototype = Object.create(Field.prototype)).constructor = MapField).className = \"MapField\";\n\nvar types,\n    util;\n\n/**\n * Constructs a new map field instance.\n * @classdesc Reflected map field.\n * @extends FieldBase\n * @constructor\n * @param {string} name Unique name within its namespace\n * @param {number} id Unique id within its namespace\n * @param {string} keyType Key type\n * @param {string} type Value type\n * @param {Object.<string,*>} [options] Declared options\n * @param {string} [comment] Comment associated with this field\n */\nfunction MapField(name, id, keyType, type, options, comment) {\n    Field.call(this, name, id, type, undefined, undefined, options, comment);\n\n    /* istanbul ignore if */\n    if (!util.isString(keyType))\n        throw TypeError(\"keyType must be a string\");\n\n    /**\n     * Key type.\n     * @type {string}\n     */\n    this.keyType = keyType; // toJSON, marker\n\n    /**\n     * Resolved key type if not a basic type.\n     * @type {ReflectionObject|null}\n     */\n    this.resolvedKeyType = null;\n\n    // Overrides Field#map\n    this.map = true;\n}\n\n/**\n * Map field descriptor.\n * @interface IMapField\n * @extends {IField}\n * @property {string} keyType Key type\n */\n\n/**\n * Extension map field descriptor.\n * @interface IExtensionMapField\n * @extends IMapField\n * @property {string} extend Extended type\n */\n\n/**\n * Constructs a map field from a map field descriptor.\n * @param {string} name Field name\n * @param {IMapField} json Map field descriptor\n * @returns {MapField} Created map field\n * @throws {TypeError} If arguments are invalid\n */\nMapField.fromJSON = function fromJSON(name, json) {\n    return new MapField(name, json.id, json.keyType, json.type, json.options, json.comment);\n};\n\n/**\n * Converts this map field to a map field descriptor.\n * @param {IToJSONOptions} [toJSONOptions] JSON conversion options\n * @returns {IMapField} Map field descriptor\n */\nMapField.prototype.toJSON = function toJSON(toJSONOptions) {\n    var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;\n    return util.toObject([\n        \"keyType\" , this.keyType,\n        \"type\"    , this.type,\n        \"id\"      , this.id,\n        \"extend\"  , this.extend,\n        \"options\" , this.options,\n        \"comment\" , keepComments ? this.comment : undefined\n    ]);\n};\n\n/**\n * @override\n */\nMapField.prototype.resolve = function resolve() {\n    if (this.resolved)\n        return this;\n\n    // Besides a value type, map fields have a key type that may be \"any scalar type except for floating point types and bytes\"\n    if (types.mapKey[this.keyType] === undefined)\n        throw Error(\"invalid key type: \" + this.keyType);\n\n    return Field.prototype.resolve.call(this);\n};\n\n/**\n * Map field decorator (TypeScript).\n * @name MapField.d\n * @function\n * @param {number} fieldId Field id\n * @param {\"int32\"|\"uint32\"|\"sint32\"|\"fixed32\"|\"sfixed32\"|\"int64\"|\"uint64\"|\"sint64\"|\"fixed64\"|\"sfixed64\"|\"bool\"|\"string\"} fieldKeyType Field key type\n * @param {\"double\"|\"float\"|\"int32\"|\"uint32\"|\"sint32\"|\"fixed32\"|\"sfixed32\"|\"int64\"|\"uint64\"|\"sint64\"|\"fixed64\"|\"sfixed64\"|\"bool\"|\"string\"|\"bytes\"|Object|Constructor<{}>} fieldValueType Field value type\n * @returns {FieldDecorator} Decorator function\n * @template T extends { [key: string]: number | Long | string | boolean | Uint8Array | Buffer | number[] | Message<{}> }\n */\nMapField.d = function decorateMapField(fieldId, fieldKeyType, fieldValueType) {\n\n    // submessage value: decorate the submessage and use its name as the type\n    if (typeof fieldValueType === \"function\")\n        fieldValueType = util.decorateType(fieldValueType).name;\n\n    // enum reference value: create a reflected copy of the enum and keep reuseing it\n    else if (fieldValueType && typeof fieldValueType === \"object\")\n        fieldValueType = util.decorateEnum(fieldValueType).name;\n\n    return function mapFieldDecorator(prototype, fieldName) {\n        util.decorateType(prototype.constructor)\n            .add(new MapField(fieldName, fieldId, fieldKeyType, fieldValueType));\n    };\n};\n\nMapField._configure = function(){\n    types   = require(30);\n    util    = require(32);\n};","\"use strict\";\nmodule.exports = Message;\n\nvar util;\n\n/**\n * Constructs a new message instance.\n * @classdesc Abstract runtime message.\n * @constructor\n * @param {Properties<T>} [properties] Properties to set\n * @template T extends object\n */\nfunction Message(properties) {\n    // not used internally\n    if (properties)\n        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n            this[keys[i]] = properties[keys[i]];\n}\n\n/**\n * Reference to the reflected type.\n * @name Message.$type\n * @type {Type}\n * @readonly\n */\n\n/**\n * Reference to the reflected type.\n * @name Message#$type\n * @type {Type}\n * @readonly\n */\n\n/*eslint-disable valid-jsdoc*/\n\n/**\n * Creates a new message of this type using the specified properties.\n * @param {Object.<string,*>} [properties] Properties to set\n * @returns {Message<T>} Message instance\n * @template T extends Message<T>\n * @this Constructor<T>\n */\nMessage.create = function create(properties) {\n    return this.$type.create(properties);\n};\n\n/**\n * Encodes a message of this type.\n * @param {T|Object.<string,*>} message Message to encode\n * @param {Writer} [writer] Writer to use\n * @returns {Writer} Writer\n * @template T extends Message<T>\n * @this Constructor<T>\n */\nMessage.encode = function encode(message, writer) {\n    if(!arguments.length){\n        return this.$type.encode(this);\n    }else if (arguments.length == 1){\n        return this.$type.encode(arguments[0]);\n    }else{\n        return this.$type.encode(arguments[0], arguments[1]);\n    }\n    //return this.$type.encode(message, writer);\n};\n\n/**\n * Encodes a message of this type preceeded by its length as a varint.\n * @param {T|Object.<string,*>} message Message to encode\n * @param {Writer} [writer] Writer to use\n * @returns {Writer} Writer\n * @template T extends Message<T>\n * @this Constructor<T>\n */\nMessage.encodeDelimited = function encodeDelimited(message, writer) {\n    return this.$type.encodeDelimited(message, writer);\n};\n\n/**\n * Decodes a message of this type.\n * @name Message.decode\n * @function\n * @param {Reader|Uint8Array} reader Reader or buffer to decode\n * @returns {T} Decoded message\n * @template T extends Message<T>\n * @this Constructor<T>\n */\nMessage.decode = function decode(reader) {\n    return this.$type.decode(reader);\n};\n\n/**\n * Decodes a message of this type preceeded by its length as a varint.\n * @name Message.decodeDelimited\n * @function\n * @param {Reader|Uint8Array} reader Reader or buffer to decode\n * @returns {T} Decoded message\n * @template T extends Message<T>\n * @this Constructor<T>\n */\nMessage.decodeDelimited = function decodeDelimited(reader) {\n    return this.$type.decodeDelimited(reader);\n};\n\n/**\n * Verifies a message of this type.\n * @name Message.verify\n * @function\n * @param {Object.<string,*>} message Plain object to verify\n * @returns {string|null} `null` if valid, otherwise the reason why it is not\n */\nMessage.verify = function verify(message) {\n    return this.$type.verify(message);\n};\n\n/**\n * Creates a new message of this type from a plain object. Also converts values to their respective internal types.\n * @param {Object.<string,*>} object Plain object\n * @returns {T} Message instance\n * @template T extends Message<T>\n * @this Constructor<T>\n */\nMessage.fromObject = function fromObject(object) {\n    return this.$type.fromObject(object);\n};\n\n/**\n * Creates a plain object from a message of this type. Also converts values to other types if specified.\n * @param {T} message Message instance\n * @param {IConversionOptions} [options] Conversion options\n * @returns {Object.<string,*>} Plain object\n * @template T extends Message<T>\n * @this Constructor<T>\n */\nMessage.toObject = function toObject(message, options) {\n    message = message || this;\n    return this.$type.toObject(message, options);\n};\n\n/**\n * Converts this message to JSON.\n * @returns {Object.<string,*>} JSON object\n */\nMessage.prototype.toJSON = function toJSON() {\n    return this.$type.toObject(this, util.toJSONOptions);\n};\n\n\n\nMessage.set  = function(key,value){\n    Message[key] = value;\n};\n\nMessage.get = function (key){\n    return Message[key];\n};\n/*eslint-enable valid-jsdoc*/\n\nMessage._configure = function(){\n    util = require(32);\n}","\"use strict\";\nmodule.exports = Method;\n\n// extends ReflectionObject\nvar ReflectionObject = require(18);\n((Method.prototype = Object.create(ReflectionObject.prototype)).constructor = Method).className = \"Method\";\n\nvar util;\n\n/**\n * Constructs a new service method instance.\n * @classdesc Reflected service method.\n * @extends ReflectionObject\n * @constructor\n * @param {string} name Method name\n * @param {string|undefined} type Method type, usually `\"rpc\"`\n * @param {string} requestType Request message type\n * @param {string} responseType Response message type\n * @param {boolean|Object.<string,*>} [requestStream] Whether the request is streamed\n * @param {boolean|Object.<string,*>} [responseStream] Whether the response is streamed\n * @param {Object.<string,*>} [options] Declared options\n * @param {string} [comment] The comment for this method\n */\nfunction Method(name, type, requestType, responseType, requestStream, responseStream, options, comment) {\n\n    /* istanbul ignore next */\n    if (util.isObject(requestStream)) {\n        options = requestStream;\n        requestStream = responseStream = undefined;\n    } else if (util.isObject(responseStream)) {\n        options = responseStream;\n        responseStream = undefined;\n    }\n\n    /* istanbul ignore if */\n    if (!(type === undefined || util.isString(type)))\n        throw TypeError(\"type must be a string\");\n\n    /* istanbul ignore if */\n    if (!util.isString(requestType))\n        throw TypeError(\"requestType must be a string\");\n\n    /* istanbul ignore if */\n    if (!util.isString(responseType))\n        throw TypeError(\"responseType must be a string\");\n\n    ReflectionObject.call(this, name, options);\n\n    /**\n     * Method type.\n     * @type {string}\n     */\n    this.type = type || \"rpc\"; // toJSON\n\n    /**\n     * Request type.\n     * @type {string}\n     */\n    this.requestType = requestType; // toJSON, marker\n\n    /**\n     * Whether requests are streamed or not.\n     * @type {boolean|undefined}\n     */\n    this.requestStream = requestStream ? true : undefined; // toJSON\n\n    /**\n     * Response type.\n     * @type {string}\n     */\n    this.responseType = responseType; // toJSON\n\n    /**\n     * Whether responses are streamed or not.\n     * @type {boolean|undefined}\n     */\n    this.responseStream = responseStream ? true : undefined; // toJSON\n\n    /**\n     * Resolved request type.\n     * @type {Type|null}\n     */\n    this.resolvedRequestType = null;\n\n    /**\n     * Resolved response type.\n     * @type {Type|null}\n     */\n    this.resolvedResponseType = null;\n\n    /**\n     * Comment for this method\n     * @type {string|null}\n     */\n    this.comment = comment;\n}\n\n/**\n * Method descriptor.\n * @interface IMethod\n * @property {string} [type=\"rpc\"] Method type\n * @property {string} requestType Request type\n * @property {string} responseType Response type\n * @property {boolean} [requestStream=false] Whether requests are streamed\n * @property {boolean} [responseStream=false] Whether responses are streamed\n * @property {Object.<string,*>} [options] Method options\n */\n\n/**\n * Constructs a method from a method descriptor.\n * @param {string} name Method name\n * @param {IMethod} json Method descriptor\n * @returns {Method} Created method\n * @throws {TypeError} If arguments are invalid\n */\nMethod.fromJSON = function fromJSON(name, json) {\n    return new Method(name, json.type, json.requestType, json.responseType, json.requestStream, json.responseStream, json.options, json.comment);\n};\n\n/**\n * Converts this method to a method descriptor.\n * @param {IToJSONOptions} [toJSONOptions] JSON conversion options\n * @returns {IMethod} Method descriptor\n */\nMethod.prototype.toJSON = function toJSON(toJSONOptions) {\n    var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;\n    return util.toObject([\n        \"type\"           , this.type !== \"rpc\" && /* istanbul ignore next */ this.type || undefined,\n        \"requestType\"    , this.requestType,\n        \"requestStream\"  , this.requestStream,\n        \"responseType\"   , this.responseType,\n        \"responseStream\" , this.responseStream,\n        \"options\"        , this.options,\n        \"comment\"        , keepComments ? this.comment : undefined\n    ]);\n};\n\n/**\n * @override\n */\nMethod.prototype.resolve = function resolve() {\n\n    /* istanbul ignore if */\n    if (this.resolved)\n        return this;\n\n    this.resolvedRequestType = this.parent.lookupType(this.requestType);\n    this.resolvedResponseType = this.parent.lookupType(this.responseType);\n\n    return ReflectionObject.prototype.resolve.call(this);\n};\n\nMethod._configure = function (){\n    util = require(32);\n}","\nmodule.exports = Namespace;\n\n// extends ReflectionObject\nvar ReflectionObject = require(18);\n((Namespace.prototype = Object.create(ReflectionObject.prototype)).constructor = Namespace).className = \"Namespace\";\n\nvar Enum,\n    Field,\n    util;\n\nvar Type;    // cyclic\nvar Service;\n\n/**\n * Constructs a new namespace instance.\n * @name Namespace\n * @classdesc Reflected namespace.\n * @extends NamespaceBase\n * @constructor\n * @param {string} name Namespace name\n * @param {Object.<string,*>} [options] Declared options\n */\n\n/**\n * Constructs a namespace from JSON.\n * @memberof Namespace\n * @function\n * @param {string} name Namespace name\n * @param {Object.<string,*>} json JSON object\n * @returns {Namespace} Created namespace\n * @throws {TypeError} If arguments are invalid\n */\nNamespace.fromJSON = function fromJSON(name, json) {\n    return new Namespace(name, json.options).addJSON(json.nested);\n};\n\n/**\n * Converts an array of reflection objects to JSON.\n * @memberof Namespace\n * @param {ReflectionObject[]} array Object array\n * @param {IToJSONOptions} [toJSONOptions] JSON conversion options\n * @returns {Object.<string,*>|undefined} JSON object or `undefined` when array is empty\n */\nfunction arrayToJSON(array, toJSONOptions) {\n    if (!(array && array.length))\n        return undefined;\n    var obj = {};\n    for (var i = 0; i < array.length; ++i)\n        obj[array[i].name] = array[i].toJSON(toJSONOptions);\n    return obj;\n}\n\nNamespace.arrayToJSON = arrayToJSON;\n\n/**\n * Tests if the specified id is reserved.\n * @param {Array.<number[]|string>|undefined} reserved Array of reserved ranges and names\n * @param {number} id Id to test\n * @returns {boolean} `true` if reserved, otherwise `false`\n */\nNamespace.isReservedId = function isReservedId(reserved, id) {\n    if (reserved)\n        for (var i = 0; i < reserved.length; ++i)\n            if (typeof reserved[i] !== \"string\" && reserved[i][0] <= id && reserved[i][1] >= id)\n                return true;\n    return false;\n};\n\n/**\n * Tests if the specified name is reserved.\n * @param {Array.<number[]|string>|undefined} reserved Array of reserved ranges and names\n * @param {string} name Name to test\n * @returns {boolean} `true` if reserved, otherwise `false`\n */\nNamespace.isReservedName = function isReservedName(reserved, name) {\n    if (reserved)\n        for (var i = 0; i < reserved.length; ++i)\n            if (reserved[i] === name)\n                return true;\n    return false;\n};\n\n/**\n * Not an actual constructor. Use {@link Namespace} instead.\n * @classdesc Base class of all reflection objects containing nested objects. This is not an actual class but here for the sake of having consistent type definitions.\n * @exports NamespaceBase\n * @extends ReflectionObject\n * @abstract\n * @constructor\n * @param {string} name Namespace name\n * @param {Object.<string,*>} [options] Declared options\n * @see {@link Namespace}\n */\nfunction Namespace(name, options) {\n    ReflectionObject.call(this, name, options);\n\n    /**\n     * Nested objects by name.\n     * @type {Object.<string,ReflectionObject>|undefined}\n     */\n    this.nested = undefined; // toJSON\n\n    /**\n     * Cached nested objects as an array.\n     * @type {ReflectionObject[]|null}\n     * @private\n     */\n    this._nestedArray = null;\n}\n\nfunction clearCache(namespace) {\n    namespace._nestedArray = null;\n    return namespace;\n}\n\n/**\n * Nested objects of this namespace as an array for iteration.\n * @name NamespaceBase#nestedArray\n * @type {ReflectionObject[]}\n * @readonly\n */\nObject.defineProperty(Namespace.prototype, \"nestedArray\", {\n    get: function() {\n        return this._nestedArray || (this._nestedArray = util.toArray(this.nested));\n    }\n});\n\n/**\n * Namespace descriptor.\n * @interface INamespace\n * @property {Object.<string,*>} [options] Namespace options\n * @property {Object.<string,AnyNestedObject>} [nested] Nested object descriptors\n */\n\n/**\n * Any extension field descriptor.\n * @typedef AnyExtensionField\n * @type {IExtensionField|IExtensionMapField}\n */\n\n/**\n * Any nested object descriptor.\n * @typedef AnyNestedObject\n * @type {IEnum|IType|IService|AnyExtensionField|INamespace}\n */\n// ^ BEWARE: VSCode hangs forever when using more than 5 types (that's why AnyExtensionField exists in the first place)\n\n/**\n * Converts this namespace to a namespace descriptor.\n * @param {IToJSONOptions} [toJSONOptions] JSON conversion options\n * @returns {INamespace} Namespace descriptor\n */\nNamespace.prototype.toJSON = function toJSON(toJSONOptions) {\n    return util.toObject([\n        \"options\" , this.options,\n        \"nested\"  , arrayToJSON(this.nestedArray, toJSONOptions)\n    ]);\n};\n\n/**\n * Adds nested objects to this namespace from nested object descriptors.\n * @param {Object.<string,AnyNestedObject>} nestedJson Any nested object descriptors\n * @returns {Namespace} `this`\n */\nNamespace.prototype.addJSON = function addJSON(nestedJson) {\n    var ns = this;\n    /* istanbul ignore else */\n    if (nestedJson) {\n        for (var names = Object.keys(nestedJson), i = 0, nested; i < names.length; ++i) {\n            nested = nestedJson[names[i]];\n            ns.add( // most to least likely\n                ( nested.fields !== undefined\n                    ? Type.fromJSON\n                    : nested.values !== undefined\n                    ? Enum.fromJSON\n                    : nested.methods !== undefined\n                    ? Service.fromJSON\n                    : nested.id !== undefined\n                    ? Field.fromJSON\n                    : Namespace.fromJSON )(names[i], nested)\n            );\n        }\n    }\n    return this;\n};\n\n/**\n * Gets the nested object of the specified name.\n * @param {string} name Nested object name\n * @returns {ReflectionObject|null} The reflection object or `null` if it doesn't exist\n */\nNamespace.prototype.get = function get(name) {\n    return this.nested && this.nested[name]\n        || null;\n};\n\n/**\n * Gets the values of the nested {@link Enum|enum} of the specified name.\n * This methods differs from {@link Namespace#get|get} in that it returns an enum's values directly and throws instead of returning `null`.\n * @param {string} name Nested enum name\n * @returns {Object.<string,number>} Enum values\n * @throws {Error} If there is no such enum\n */\nNamespace.prototype.getEnum = function getEnum(name) {\n    if (this.nested && this.nested[name] instanceof Enum)\n        return this.nested[name].values;\n    throw Error(\"no such enum: \" + name);\n};\n\n/**\n * Adds a nested object to this namespace.\n * @param {ReflectionObject} object Nested object to add\n * @returns {Namespace} `this`\n * @throws {TypeError} If arguments are invalid\n * @throws {Error} If there is already a nested object with this name\n */\nNamespace.prototype.add = function add(object) {\n\n    if (!(object instanceof Field && object.extend !== undefined || object instanceof Type || object instanceof Enum || object instanceof Service || object instanceof Namespace))\n        throw TypeError(\"object must be a valid nested object\");\n\n    if (!this.nested)\n        this.nested = {};\n    else {\n        var prev = this.get(object.name);\n        if (prev) {\n            if (prev instanceof Namespace && object instanceof Namespace && !(prev instanceof Type || prev instanceof Service)) {\n                // replace plain namespace but keep existing nested elements and options\n                var nested = prev.nestedArray;\n                for (var i = 0; i < nested.length; ++i)\n                    object.add(nested[i]);\n                this.remove(prev);\n                if (!this.nested)\n                    this.nested = {};\n                object.setOptions(prev.options, true);\n\n            } else\n                throw Error(\"duplicate name '\" + object.name + \"' in \" + this);\n        }\n    }\n    this.nested[object.name] = object;\n    object.onAdd(this);\n    return clearCache(this);\n};\n\n/**\n * Removes a nested object from this namespace.\n * @param {ReflectionObject} object Nested object to remove\n * @returns {Namespace} `this`\n * @throws {TypeError} If arguments are invalid\n * @throws {Error} If `object` is not a member of this namespace\n */\nNamespace.prototype.remove = function remove(object) {\n\n    if (!(object instanceof ReflectionObject))\n        throw TypeError(\"object must be a ReflectionObject\");\n    if (object.parent !== this)\n        throw Error(object + \" is not a member of \" + this);\n\n    delete this.nested[object.name];\n    if (!Object.keys(this.nested).length)\n        this.nested = undefined;\n\n    object.onRemove(this);\n    return clearCache(this);\n};\n\n/**\n * Defines additial namespaces within this one if not yet existing.\n * @param {string|string[]} path Path to create\n * @param {*} [json] Nested types to create from JSON\n * @returns {Namespace} Pointer to the last namespace created or `this` if path is empty\n */\nNamespace.prototype.define = function define(path, json) {\n\n    if (util.isString(path))\n        path = path.split(\".\");\n    else if (!Array.isArray(path))\n        throw TypeError(\"illegal path\");\n    if (path && path.length && path[0] === \"\")\n        throw Error(\"path must be relative\");\n\n    var ptr = this;\n    while (path.length > 0) {\n        var part = path.shift();\n        if (ptr.nested && ptr.nested[part]) {\n            ptr = ptr.nested[part];\n            if (!(ptr instanceof Namespace))\n                throw Error(\"path conflicts with non-namespace objects\");\n        } else\n            ptr.add(ptr = new Namespace(part));\n    }\n    if (json)\n        ptr.addJSON(json);\n    return ptr;\n};\n\n/**\n * Resolves this namespace's and all its nested objects' type references. Useful to validate a reflection tree, but comes at a cost.\n * @returns {Namespace} `this`\n */\nNamespace.prototype.resolveAll = function resolveAll() {\n    var nested = this.nestedArray, i = 0;\n    while (i < nested.length)\n        if (nested[i] instanceof Namespace)\n            nested[i++].resolveAll();\n        else\n            nested[i++].resolve();\n    return this.resolve();\n};\n\n/**\n * Recursively looks up the reflection object matching the specified path in the scope of this namespace.\n * @param {string|string[]} path Path to look up\n * @param {*|Array.<*>} filterTypes Filter types, any combination of the constructors of `protobuf.Type`, `protobuf.Enum`, `protobuf.Service` etc.\n * @param {boolean} [parentAlreadyChecked=false] If known, whether the parent has already been checked\n * @returns {ReflectionObject|null} Looked up object or `null` if none could be found\n */\nNamespace.prototype.lookup = function lookup(path, filterTypes, parentAlreadyChecked) {\n\n    /* istanbul ignore next */\n    if (typeof filterTypes === \"boolean\") {\n        parentAlreadyChecked = filterTypes;\n        filterTypes = undefined;\n    } else if (filterTypes && !Array.isArray(filterTypes))\n        filterTypes = [ filterTypes ];\n\n    if (util.isString(path) && path.length) {\n        if (path === \".\")\n            return this.root;\n        path = path.split(\".\");\n    } else if (!path.length)\n        return this;\n\n    // Start at root if path is absolute\n    if (path[0] === \"\")\n        return this.root.lookup(path.slice(1), filterTypes);\n\n    // Test if the first part matches any nested object, and if so, traverse if path contains more\n    var found = this.get(path[0]);\n    if (found) {\n        if (path.length === 1) {\n            if (!filterTypes || filterTypes.indexOf(found.constructor) > -1)\n                return found;\n        } else if (found instanceof Namespace && (found = found.lookup(path.slice(1), filterTypes, true)))\n            return found;\n\n        // Otherwise try each nested namespace\n    } else\n        for (var i = 0; i < this.nestedArray.length; ++i)\n            if (this._nestedArray[i] instanceof Namespace && (found = this._nestedArray[i].lookup(path, filterTypes, true)))\n                return found;\n\n    // If there hasn't been a match, try again at the parent\n    if (this.parent === null || parentAlreadyChecked)\n        return null;\n    return this.parent.lookup(path, filterTypes);\n};\n\n/**\n * Looks up the reflection object at the specified path, relative to this namespace.\n * @name NamespaceBase#lookup\n * @function\n * @param {string|string[]} path Path to look up\n * @param {boolean} [parentAlreadyChecked=false] Whether the parent has already been checked\n * @returns {ReflectionObject|null} Looked up object or `null` if none could be found\n * @variation 2\n */\n// lookup(path: string, [parentAlreadyChecked: boolean])\n\n/**\n * Looks up the {@link Type|type} at the specified path, relative to this namespace.\n * Besides its signature, this methods differs from {@link Namespace#lookup|lookup} in that it throws instead of returning `null`.\n * @param {string|string[]} path Path to look up\n * @returns {Type} Looked up type\n * @throws {Error} If `path` does not point to a type\n */\nNamespace.prototype.lookupType = function lookupType(path) {\n    var found = this.lookup(path, [ Type ]);\n    if (!found)\n        throw Error(\"no such type: \" + path);\n    return found;\n};\n\n/**\n * Looks up the values of the {@link Enum|enum} at the specified path, relative to this namespace.\n * Besides its signature, this methods differs from {@link Namespace#lookup|lookup} in that it throws instead of returning `null`.\n * @param {string|string[]} path Path to look up\n * @returns {Enum} Looked up enum\n * @throws {Error} If `path` does not point to an enum\n */\nNamespace.prototype.lookupEnum = function lookupEnum(path) {\n    var found = this.lookup(path, [ Enum ]);\n    if (!found)\n        throw Error(\"no such Enum '\" + path + \"' in \" + this);\n    return found;\n};\n\n/**\n * Looks up the {@link Type|type} or {@link Enum|enum} at the specified path, relative to this namespace.\n * Besides its signature, this methods differs from {@link Namespace#lookup|lookup} in that it throws instead of returning `null`.\n * @param {string|string[]} path Path to look up\n * @returns {Type} Looked up type or enum\n * @throws {Error} If `path` does not point to a type or enum\n */\nNamespace.prototype.lookupTypeOrEnum = function lookupTypeOrEnum(path) {\n    var found = this.lookup(path, [ Type, Enum ]);\n    if (!found)\n        throw Error(\"no such Type or Enum '\" + path + \"' in \" + this);\n    return found;\n};\n\n/**\n * Looks up the {@link Service|service} at the specified path, relative to this namespace.\n * Besides its signature, this methods differs from {@link Namespace#lookup|lookup} in that it throws instead of returning `null`.\n * @param {string|string[]} path Path to look up\n * @returns {Service} Looked up service\n * @throws {Error} If `path` does not point to a service\n */\nNamespace.prototype.lookupService = function lookupService(path) {\n    var found = this.lookup(path, [ Service ]);\n    if (!found)\n        throw Error(\"no such Service '\" + path + \"' in \" + this);\n    return found;\n};\n\nNamespace._configure = function() {\n    Enum     = require(9);\n    Field    = require(10);\n    util     = require(32);\n\n    Type     = require(29);    // cyclic\n    Service  = require(27);\n};","\"use strict\";\nmodule.exports = ReflectionObject;\n\nReflectionObject.className = \"ReflectionObject\";\nvar util;\n\nvar Root; // cyclic\n\n/**\n * Constructs a new reflection object instance.\n * @classdesc Base class of all reflection objects.\n * @constructor\n * @param {string} name Object name\n * @param {Object.<string,*>} [options] Declared options\n * @abstract\n */\nfunction ReflectionObject(name, options) {\n\n    if (!util.isString(name))\n        throw TypeError(\"name must be a string\");\n\n    if (options && !util.isObject(options))\n        throw TypeError(\"options must be an object\");\n\n    /**\n     * Options.\n     * @type {Object.<string,*>|undefined}\n     */\n    this.options = options; // toJSON\n\n    /**\n     * Unique name within its namespace.\n     * @type {string}\n     */\n    this.name = name;\n\n    /**\n     * Parent namespace.\n     * @type {Namespace|null}\n     */\n    this.parent = null;\n\n    /**\n     * Whether already resolved or not.\n     * @type {boolean}\n     */\n    this.resolved = false;\n\n    /**\n     * Comment text, if any.\n     * @type {string|null}\n     */\n    this.comment = null;\n\n    /**\n     * Defining file name.\n     * @type {string|null}\n     */\n    this.filename = null;\n}\n\nObject.defineProperties(ReflectionObject.prototype, {\n\n    /**\n     * Reference to the root namespace.\n     * @name ReflectionObject#root\n     * @type {Root}\n     * @readonly\n     */\n    root: {\n        get: function() {\n            var ptr = this;\n            while (ptr.parent !== null)\n                ptr = ptr.parent;\n            return ptr;\n        }\n    },\n\n    /**\n     * Full name including leading dot.\n     * @name ReflectionObject#fullName\n     * @type {string}\n     * @readonly\n     */\n    fullName: {\n        get: function() {\n            var path = [ this.name ],\n                ptr = this.parent;\n            while (ptr) {\n                path.unshift(ptr.name);\n                ptr = ptr.parent;\n            }\n            return path.join(\".\");\n        }\n    }\n});\n\n/**\n * Converts this reflection object to its descriptor representation.\n * @returns {Object.<string,*>} Descriptor\n * @abstract\n */\nReflectionObject.prototype.toJSON = /* istanbul ignore next */ function toJSON() {\n    throw Error(); // not implemented, shouldn't happen\n};\n\n/**\n * Called when this object is added to a parent.\n * @param {ReflectionObject} parent Parent added to\n * @returns {undefined}\n */\nReflectionObject.prototype.onAdd = function onAdd(parent) {\n    if (this.parent && this.parent !== parent)\n        this.parent.remove(this);\n    this.parent = parent;\n    this.resolved = false;\n    var root = parent.root;\n    if (root instanceof Root)\n        root._handleAdd(this);\n};\n\n/**\n * Called when this object is removed from a parent.\n * @param {ReflectionObject} parent Parent removed from\n * @returns {undefined}\n */\nReflectionObject.prototype.onRemove = function onRemove(parent) {\n    var root = parent.root;\n    if (root instanceof Root)\n        root._handleRemove(this);\n    this.parent = null;\n    this.resolved = false;\n};\n\n/**\n * Resolves this objects type references.\n * @returns {ReflectionObject} `this`\n */\nReflectionObject.prototype.resolve = function resolve() {\n    if (this.resolved)\n        return this;\n    if (this.root instanceof Root)\n        this.resolved = true; // only if part of a root\n    return this;\n};\n\n/**\n * Gets an option value.\n * @param {string} name Option name\n * @returns {*} Option value or `undefined` if not set\n */\nReflectionObject.prototype.getOption = function getOption(name) {\n    if (this.options)\n        return this.options[name];\n    return undefined;\n};\n\n/**\n * Sets an option.\n * @param {string} name Option name\n * @param {*} value Option value\n * @param {boolean} [ifNotSet] Sets the option only if it isn't currently set\n * @returns {ReflectionObject} `this`\n */\nReflectionObject.prototype.setOption = function setOption(name, value, ifNotSet) {\n    if (!ifNotSet || !this.options || this.options[name] === undefined)\n        (this.options || (this.options = {}))[name] = value;\n    return this;\n};\n\n/**\n * Sets multiple options.\n * @param {Object.<string,*>} options Options to set\n * @param {boolean} [ifNotSet] Sets an option only if it isn't currently set\n * @returns {ReflectionObject} `this`\n */\nReflectionObject.prototype.setOptions = function setOptions(options, ifNotSet) {\n    if (options)\n        for (var keys = Object.keys(options), i = 0; i < keys.length; ++i)\n            this.setOption(keys[i], options[keys[i]], ifNotSet);\n    return this;\n};\n\n/**\n * Converts this instance to its string representation.\n * @returns {string} Class name[, space, full name]\n */\nReflectionObject.prototype.toString = function toString() {\n    var className = this.constructor.className,\n        fullName  = this.fullName;\n    if (fullName.length)\n        return className + \" \" + fullName;\n    return className;\n};\n\nReflectionObject._configure = function(Root_) {\n    Root = require(24);\n    util = require(32);\n};\n","module.exports = OneOf;\n\n// extends ReflectionObject\nvar ReflectionObject = require(18);\n((OneOf.prototype = Object.create(ReflectionObject.prototype)).constructor = OneOf).className = \"OneOf\";\n\nvar Field;\nvar util;\n\n/**\n * Constructs a new oneof instance.\n * @classdesc Reflected oneof.\n * @extends ReflectionObject\n * @constructor\n * @param {string} name Oneof name\n * @param {string[]|Object.<string,*>} [fieldNames] Field names\n * @param {Object.<string,*>} [options] Declared options\n * @param {string} [comment] Comment associated with this field\n */\nfunction OneOf(name, fieldNames, options, comment) {\n    if (!Array.isArray(fieldNames)) {\n        options = fieldNames;\n        fieldNames = undefined;\n    }\n    ReflectionObject.call(this, name, options);\n\n    /* istanbul ignore if */\n    if (!(fieldNames === undefined || Array.isArray(fieldNames)))\n        throw TypeError(\"fieldNames must be an Array\");\n\n    /**\n     * Field names that belong to this oneof.\n     * @type {string[]}\n     */\n    this.oneof = fieldNames || []; // toJSON, marker\n\n    /**\n     * Fields that belong to this oneof as an array for iteration.\n     * @type {Field[]}\n     * @readonly\n     */\n    this.fieldsArray = []; // declared readonly for conformance, possibly not yet added to parent\n\n    /**\n     * Comment for this field.\n     * @type {string|null}\n     */\n    this.comment = comment;\n}\n\n/**\n * Oneof descriptor.\n * @interface IOneOf\n * @property {Array.<string>} oneof Oneof field names\n * @property {Object.<string,*>} [options] Oneof options\n */\n\n/**\n * Constructs a oneof from a oneof descriptor.\n * @param {string} name Oneof name\n * @param {IOneOf} json Oneof descriptor\n * @returns {OneOf} Created oneof\n * @throws {TypeError} If arguments are invalid\n */\nOneOf.fromJSON = function fromJSON(name, json) {\n    return new OneOf(name, json.oneof, json.options, json.comment);\n};\n\n/**\n * Converts this oneof to a oneof descriptor.\n * @param {IToJSONOptions} [toJSONOptions] JSON conversion options\n * @returns {IOneOf} Oneof descriptor\n */\nOneOf.prototype.toJSON = function toJSON(toJSONOptions) {\n    var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;\n    return util.toObject([\n        \"options\" , this.options,\n        \"oneof\"   , this.oneof,\n        \"comment\" , keepComments ? this.comment : undefined\n    ]);\n};\n\n/**\n * Adds the fields of the specified oneof to the parent if not already done so.\n * @param {OneOf} oneof The oneof\n * @returns {undefined}\n * @inner\n * @ignore\n */\nfunction addFieldsToParent(oneof) {\n    if (oneof.parent)\n        for (var i = 0; i < oneof.fieldsArray.length; ++i)\n            if (!oneof.fieldsArray[i].parent)\n                oneof.parent.add(oneof.fieldsArray[i]);\n}\n\n/**\n * Adds a field to this oneof and removes it from its current parent, if any.\n * @param {Field} field Field to add\n * @returns {OneOf} `this`\n */\nOneOf.prototype.add = function add(field) {\n\n    /* istanbul ignore if */\n    if (!(field instanceof Field))\n        throw TypeError(\"field must be a Field\");\n\n    if (field.parent && field.parent !== this.parent)\n        field.parent.remove(field);\n    this.oneof.push(field.name);\n    this.fieldsArray.push(field);\n    field.partOf = this; // field.parent remains null\n    addFieldsToParent(this);\n    return this;\n};\n\n/**\n * Removes a field from this oneof and puts it back to the oneof's parent.\n * @param {Field} field Field to remove\n * @returns {OneOf} `this`\n */\nOneOf.prototype.remove = function remove(field) {\n\n    /* istanbul ignore if */\n    if (!(field instanceof Field))\n        throw TypeError(\"field must be a Field\");\n\n    var index = this.fieldsArray.indexOf(field);\n\n    /* istanbul ignore if */\n    if (index < 0)\n        throw Error(field + \" is not a member of \" + this);\n\n    this.fieldsArray.splice(index, 1);\n    index = this.oneof.indexOf(field.name);\n\n    /* istanbul ignore else */\n    if (index > -1) // theoretical\n        this.oneof.splice(index, 1);\n\n    field.partOf = null;\n    return this;\n};\n\n/**\n * @override\n */\nOneOf.prototype.onAdd = function onAdd(parent) {\n    ReflectionObject.prototype.onAdd.call(this, parent);\n    var self = this;\n    // Collect present fields\n    for (var i = 0; i < this.oneof.length; ++i) {\n        var field = parent.get(this.oneof[i]);\n        if (field && !field.partOf) {\n            field.partOf = self;\n            self.fieldsArray.push(field);\n        }\n    }\n    // Add not yet present fields\n    addFieldsToParent(this);\n};\n\n/**\n * @override\n */\nOneOf.prototype.onRemove = function onRemove(parent) {\n    for (var i = 0, field; i < this.fieldsArray.length; ++i)\n        if ((field = this.fieldsArray[i]).parent)\n            field.parent.remove(field);\n    ReflectionObject.prototype.onRemove.call(this, parent);\n};\n\n/**\n * Decorator function as returned by {@link OneOf.d} (TypeScript).\n * @typedef OneOfDecorator\n * @type {function}\n * @param {Object} prototype Target prototype\n * @param {string} oneofName OneOf name\n * @returns {undefined}\n */\n\n/**\n * OneOf decorator (TypeScript).\n * @function\n * @param {...string} fieldNames Field names\n * @returns {OneOfDecorator} Decorator function\n * @template T extends string\n */\nOneOf.d = function decorateOneOf() {\n    var fieldNames = new Array(arguments.length),\n        index = 0;\n    while (index < arguments.length)\n        fieldNames[index] = arguments[index++];\n    return function oneOfDecorator(prototype, oneofName) {\n        util.decorateType(prototype.constructor)\n            .add(new OneOf(oneofName, fieldNames));\n        Object.defineProperty(prototype, oneofName, {\n            get: util.oneOfGetter(fieldNames),\n            set: util.oneOfSetter(fieldNames)\n        });\n    };\n};\n\nOneOf._configure = function (){\n    Field = require(10);\n    util = require(32);\n};","\"use strict\";\nmodule.exports = parse;\n\nparse.filename = null;\nparse.defaults = { keepCase: false };\n\nvar tokenize,\n    Root,\n    Type,\n    Field,\n    MapField,\n    OneOf,\n    Enum,\n    Service,\n    Method,\n    types,\n    util;\n\nvar base10Re    = /^[1-9][0-9]*$/,\n    base10NegRe = /^-?[1-9][0-9]*$/,\n    base16Re    = /^0[x][0-9a-fA-F]+$/,\n    base16NegRe = /^-?0[x][0-9a-fA-F]+$/,\n    base8Re     = /^0[0-7]+$/,\n    base8NegRe  = /^-?0[0-7]+$/,\n    numberRe    = /^(?![eE])[0-9]*(?:\\.[0-9]*)?(?:[eE][+-]?[0-9]+)?$/,\n    nameRe      = /^[a-zA-Z_][a-zA-Z_0-9]*$/,\n    typeRefRe   = /^(?:\\.?[a-zA-Z_][a-zA-Z_0-9]*)+$/,\n    fqTypeRefRe = /^(?:\\.[a-zA-Z][a-zA-Z_0-9]*)+$/;\n\n/**\n * Result object returned from {@link parse}.\n * @interface IParserResult\n * @property {string|undefined} package Package name, if declared\n * @property {string[]|undefined} imports Imports, if any\n * @property {string[]|undefined} weakImports Weak imports, if any\n * @property {string|undefined} syntax Syntax, if specified (either `\"proto2\"` or `\"proto3\"`)\n * @property {Root} root Populated root instance\n */\n\n/**\n * Options modifying the behavior of {@link parse}.\n * @interface IParseOptions\n * @property {boolean} [keepCase=false] Keeps field casing instead of converting to camel case\n * @property {boolean} [alternateCommentMode=false] Recognize double-slash comments in addition to doc-block comments.\n */\n\n/**\n * Options modifying the behavior of JSON serialization.\n * @interface IToJSONOptions\n * @property {boolean} [keepComments=false] Serializes comments.\n */\n\n/**\n * Parses the given .proto source and returns an object with the parsed contents.\n * @param {string} source Source contents\n * @param {Root} root Root to populate\n * @param {IParseOptions} [options] Parse options. Defaults to {@link parse.defaults} when omitted.\n * @returns {IParserResult} Parser result\n * @property {string} filename=null Currently processing file name for error reporting, if known\n * @property {IParseOptions} defaults Default {@link IParseOptions}\n */\nfunction parse(source, root, options) {\n    /* eslint-disable callback-return */\n    if (!(root instanceof Root)) {\n        options = root;\n        root = new Root();\n    }\n    if (!options)\n        options = parse.defaults;\n\n    var tn = tokenize(source, options.alternateCommentMode || false),\n        next = tn.next,\n        push = tn.push,\n        peek = tn.peek,\n        skip = tn.skip,\n        cmnt = tn.cmnt;\n\n    var head = true,\n        pkg,\n        imports,\n        weakImports,\n        syntax,\n        isProto3 = false;\n\n    var ptr = root;\n\n    var applyCase = options.keepCase ? function(name) { return name; } : util.camelCase;\n\n    /* istanbul ignore next */\n    function illegal(token, name, insideTryCatch) {\n        var filename = parse.filename;\n        if (!insideTryCatch)\n            parse.filename = null;\n        return Error(\"illegal \" + (name || \"token\") + \" '\" + token + \"' (\" + (filename ? filename + \", \" : \"\") + \"line \" + tn.line + \")\");\n    }\n\n    function readString() {\n        var values = [],\n            token;\n        do {\n            /* istanbul ignore if */\n            if ((token = next()) !== \"\\\"\" && token !== \"'\")\n                throw illegal(token);\n\n            values.push(next());\n            skip(token);\n            token = peek();\n        } while (token === \"\\\"\" || token === \"'\");\n        return values.join(\"\");\n    }\n\n    function readValue(acceptTypeRef) {\n        var token = next();\n        switch (token) {\n            case \"'\":\n            case \"\\\"\":\n                push(token);\n                return readString();\n            case \"true\": case \"TRUE\":\n            return true;\n            case \"false\": case \"FALSE\":\n            return false;\n        }\n        try {\n            return parseNumber(token, /* insideTryCatch */ true);\n        } catch (e) {\n\n            /* istanbul ignore else */\n            if (acceptTypeRef && typeRefRe.test(token))\n                return token;\n\n            /* istanbul ignore next */\n            throw illegal(token, \"value\");\n        }\n    }\n\n    function readRanges(target, acceptStrings) {\n        var token, start;\n        do {\n            if (acceptStrings && ((token = peek()) === \"\\\"\" || token === \"'\"))\n                target.push(readString());\n            else\n                target.push([ start = parseId(next()), skip(\"to\", true) ? parseId(next()) : start ]);\n        } while (skip(\",\", true));\n        skip(\";\");\n    }\n\n    function parseNumber(token, insideTryCatch) {\n        var sign = 1;\n        if (token.charAt(0) === \"-\") {\n            sign = -1;\n            token = token.substring(1);\n        }\n        switch (token) {\n            case \"inf\": case \"INF\": case \"Inf\":\n            return sign * Infinity;\n            case \"nan\": case \"NAN\": case \"Nan\": case \"NaN\":\n            return NaN;\n            case \"0\":\n                return 0;\n        }\n        if (base10Re.test(token))\n            return sign * parseInt(token, 10);\n        if (base16Re.test(token))\n            return sign * parseInt(token, 16);\n        if (base8Re.test(token))\n            return sign * parseInt(token, 8);\n\n        /* istanbul ignore else */\n        if (numberRe.test(token))\n            return sign * parseFloat(token);\n\n        /* istanbul ignore next */\n        throw illegal(token, \"number\", insideTryCatch);\n    }\n\n    function parseId(token, acceptNegative) {\n        switch (token) {\n            case \"max\": case \"MAX\": case \"Max\":\n            return 536870911;\n            case \"0\":\n                return 0;\n        }\n\n        /* istanbul ignore if */\n        if (!acceptNegative && token.charAt(0) === \"-\")\n            throw illegal(token, \"id\");\n\n        if (base10NegRe.test(token))\n            return parseInt(token, 10);\n        if (base16NegRe.test(token))\n            return parseInt(token, 16);\n\n        /* istanbul ignore else */\n        if (base8NegRe.test(token))\n            return parseInt(token, 8);\n\n        /* istanbul ignore next */\n        throw illegal(token, \"id\");\n    }\n\n    function parsePackage() {\n\n        /* istanbul ignore if */\n        if (pkg !== undefined)\n            throw illegal(\"package\");\n\n        pkg = next();\n\n        /* istanbul ignore if */\n        if (!typeRefRe.test(pkg))\n            throw illegal(pkg, \"name\");\n\n        ptr = ptr.define(pkg);\n        skip(\";\");\n    }\n\n    function parseImport() {\n        var token = peek();\n        var whichImports;\n        switch (token) {\n            case \"weak\":\n                whichImports = weakImports || (weakImports = []);\n                next();\n                break;\n            case \"public\":\n                next();\n            // eslint-disable-line no-fallthrough\n            default:\n                whichImports = imports || (imports = []);\n                break;\n        }\n        token = readString();\n        skip(\";\");\n        whichImports.push(token);\n    }\n\n    function parseSyntax() {\n        skip(\"=\");\n        syntax = readString();\n        isProto3 = syntax === \"proto3\";\n\n        /* istanbul ignore if */\n        if (!isProto3 && syntax !== \"proto2\")\n            throw illegal(syntax, \"syntax\");\n\n        skip(\";\");\n    }\n\n    function parseCommon(parent, token) {\n        switch (token) {\n\n            case \"option\":\n                parseOption(parent, token);\n                skip(\";\");\n                return true;\n\n            case \"message\":\n                parseType(parent, token);\n                return true;\n\n            case \"enum\":\n                parseEnum(parent, token);\n                return true;\n\n            case \"service\":\n                parseService(parent, token);\n                return true;\n\n            case \"extend\":\n                parseExtension(parent, token);\n                return true;\n        }\n        return false;\n    }\n\n    function ifBlock(obj, fnIf, fnElse) {\n        var trailingLine = tn.line;\n        if (obj) {\n            obj.comment = cmnt(); // try block-type comment\n            obj.filename = parse.filename;\n        }\n        if (skip(\"{\", true)) {\n            var token;\n            while ((token = next()) !== \"}\")\n                fnIf(token);\n            skip(\";\", true);\n        } else {\n            if (fnElse)\n                fnElse();\n            skip(\";\");\n            if (obj && typeof obj.comment !== \"string\")\n                obj.comment = cmnt(trailingLine); // try line-type comment if no block\n        }\n    }\n\n    function parseType(parent, token) {\n\n        /* istanbul ignore if */\n        if (!nameRe.test(token = next()))\n            throw illegal(token, \"type name\");\n\n        var type = new Type(token);\n        ifBlock(type, function parseType_block(token) {\n            if (parseCommon(type, token))\n                return;\n\n            switch (token) {\n\n                case \"map\":\n                    parseMapField(type, token);\n                    break;\n\n                case \"required\":\n                case \"optional\":\n                case \"repeated\":\n                    parseField(type, token);\n                    break;\n\n                case \"oneof\":\n                    parseOneOf(type, token);\n                    break;\n\n                case \"extensions\":\n                    readRanges(type.extensions || (type.extensions = []));\n                    break;\n\n                case \"reserved\":\n                    readRanges(type.reserved || (type.reserved = []), true);\n                    break;\n\n                default:\n                    /* istanbul ignore if */\n                    if (!isProto3 || !typeRefRe.test(token))\n                        throw illegal(token);\n\n                    push(token);\n                    parseField(type, \"optional\");\n                    break;\n            }\n        });\n        parent.add(type);\n    }\n\n    function parseField(parent, rule, extend) {\n        var type = next();\n        if (type === \"group\") {\n            parseGroup(parent, rule);\n            return;\n        }\n\n        /* istanbul ignore if */\n        if (!typeRefRe.test(type))\n            throw illegal(type, \"type\");\n\n        var name = next();\n\n        /* istanbul ignore if */\n        if (!nameRe.test(name))\n            throw illegal(name, \"name\");\n\n        name = applyCase(name);\n        skip(\"=\");\n\n        var field = new Field(name, parseId(next()), type, rule, extend);\n        ifBlock(field, function parseField_block(token) {\n\n            /* istanbul ignore else */\n            if (token === \"option\") {\n                parseOption(field, token);\n                skip(\";\");\n            } else\n                throw illegal(token);\n\n        }, function parseField_line() {\n            parseInlineOptions(field);\n        });\n        parent.add(field);\n\n        // JSON defaults to packed=true if not set so we have to set packed=false explicity when\n        // parsing proto2 descriptors without the option, where applicable. This must be done for\n        // all known packable types and anything that could be an enum (= is not a basic type).\n        if (!isProto3 && field.repeated && (types.packed[type] !== undefined || types.basic[type] === undefined))\n            field.setOption(\"packed\", false, /* ifNotSet */ true);\n    }\n\n    function parseGroup(parent, rule) {\n        var name = next();\n\n        /* istanbul ignore if */\n        if (!nameRe.test(name))\n            throw illegal(name, \"name\");\n\n        var fieldName = util.lcFirst(name);\n        if (name === fieldName)\n            name = util.ucFirst(name);\n        skip(\"=\");\n        var id = parseId(next());\n        var type = new Type(name);\n        type.group = true;\n        var field = new Field(fieldName, id, name, rule);\n        field.filename = parse.filename;\n        ifBlock(type, function parseGroup_block(token) {\n            switch (token) {\n\n                case \"option\":\n                    parseOption(type, token);\n                    skip(\";\");\n                    break;\n\n                case \"required\":\n                case \"optional\":\n                case \"repeated\":\n                    parseField(type, token);\n                    break;\n\n                /* istanbul ignore next */\n                default:\n                    throw illegal(token); // there are no groups with proto3 semantics\n            }\n        });\n        parent.add(type)\n            .add(field);\n    }\n\n    function parseMapField(parent) {\n        skip(\"<\");\n        var keyType = next();\n\n        /* istanbul ignore if */\n        if (types.mapKey[keyType] === undefined)\n            throw illegal(keyType, \"type\");\n\n        skip(\",\");\n        var valueType = next();\n\n        /* istanbul ignore if */\n        if (!typeRefRe.test(valueType))\n            throw illegal(valueType, \"type\");\n\n        skip(\">\");\n        var name = next();\n\n        /* istanbul ignore if */\n        if (!nameRe.test(name))\n            throw illegal(name, \"name\");\n\n        skip(\"=\");\n        var field = new MapField(applyCase(name), parseId(next()), keyType, valueType);\n        ifBlock(field, function parseMapField_block(token) {\n\n            /* istanbul ignore else */\n            if (token === \"option\") {\n                parseOption(field, token);\n                skip(\";\");\n            } else\n                throw illegal(token);\n\n        }, function parseMapField_line() {\n            parseInlineOptions(field);\n        });\n        parent.add(field);\n    }\n\n    function parseOneOf(parent, token) {\n\n        /* istanbul ignore if */\n        if (!nameRe.test(token = next()))\n            throw illegal(token, \"name\");\n\n        var oneof = new OneOf(applyCase(token));\n        ifBlock(oneof, function parseOneOf_block(token) {\n            if (token === \"option\") {\n                parseOption(oneof, token);\n                skip(\";\");\n            } else {\n                push(token);\n                parseField(oneof, \"optional\");\n            }\n        });\n        parent.add(oneof);\n    }\n\n    function parseEnum(parent, token) {\n\n        /* istanbul ignore if */\n        if (!nameRe.test(token = next()))\n            throw illegal(token, \"name\");\n\n        var enm = new Enum(token);\n        ifBlock(enm, function parseEnum_block(token) {\n            switch(token) {\n                case \"option\":\n                    parseOption(enm, token);\n                    skip(\";\");\n                    break;\n\n                case \"reserved\":\n                    readRanges(enm.reserved || (enm.reserved = []), true);\n                    break;\n\n                default:\n                    parseEnumValue(enm, token);\n            }\n        });\n        parent.add(enm);\n    }\n\n    function parseEnumValue(parent, token) {\n\n        /* istanbul ignore if */\n        if (!nameRe.test(token))\n            throw illegal(token, \"name\");\n\n        skip(\"=\");\n        var value = parseId(next(), true),\n            dummy = {};\n        ifBlock(dummy, function parseEnumValue_block(token) {\n\n            /* istanbul ignore else */\n            if (token === \"option\") {\n                parseOption(dummy, token); // skip\n                skip(\";\");\n            } else\n                throw illegal(token);\n\n        }, function parseEnumValue_line() {\n            parseInlineOptions(dummy); // skip\n        });\n        parent.add(token, value, dummy.comment);\n    }\n\n    function parseOption(parent, token) {\n        var isCustom = skip(\"(\", true);\n\n        /* istanbul ignore if */\n        if (!typeRefRe.test(token = next()))\n            throw illegal(token, \"name\");\n\n        var name = token;\n        if (isCustom) {\n            skip(\")\");\n            name = \"(\" + name + \")\";\n            token = peek();\n            if (fqTypeRefRe.test(token)) {\n                name += token;\n                next();\n            }\n        }\n        skip(\"=\");\n        parseOptionValue(parent, name);\n    }\n\n    function parseOptionValue(parent, name) {\n        if (skip(\"{\", true)) { // { a: \"foo\" b { c: \"bar\" } }\n            do {\n                /* istanbul ignore if */\n                if (!nameRe.test(token = next()))\n                    throw illegal(token, \"name\");\n\n                if (peek() === \"{\")\n                    parseOptionValue(parent, name + \".\" + token);\n                else {\n                    skip(\":\");\n                    if (peek() === \"{\")\n                        parseOptionValue(parent, name + \".\" + token);\n                    else\n                        setOption(parent, name + \".\" + token, readValue(true));\n                }\n            } while (!skip(\"}\", true));\n        } else\n            setOption(parent, name, readValue(true));\n        // Does not enforce a delimiter to be universal\n    }\n\n    function setOption(parent, name, value) {\n        if (parent.setOption)\n            parent.setOption(name, value);\n    }\n\n    function parseInlineOptions(parent) {\n        if (skip(\"[\", true)) {\n            do {\n                parseOption(parent, \"option\");\n            } while (skip(\",\", true));\n            skip(\"]\");\n        }\n        return parent;\n    }\n\n    function parseService(parent, token) {\n\n        /* istanbul ignore if */\n        if (!nameRe.test(token = next()))\n            throw illegal(token, \"service name\");\n\n        var service = new Service(token);\n        ifBlock(service, function parseService_block(token) {\n            if (parseCommon(service, token))\n                return;\n\n            /* istanbul ignore else */\n            if (token === \"rpc\")\n                parseMethod(service, token);\n            else\n                throw illegal(token);\n        });\n        parent.add(service);\n    }\n\n    function parseMethod(parent, token) {\n        var type = token;\n\n        /* istanbul ignore if */\n        if (!nameRe.test(token = next()))\n            throw illegal(token, \"name\");\n\n        var name = token,\n            requestType, requestStream,\n            responseType, responseStream;\n\n        skip(\"(\");\n        if (skip(\"stream\", true))\n            requestStream = true;\n\n        /* istanbul ignore if */\n        if (!typeRefRe.test(token = next()))\n            throw illegal(token);\n\n        requestType = token;\n        skip(\")\"); skip(\"returns\"); skip(\"(\");\n        if (skip(\"stream\", true))\n            responseStream = true;\n\n        /* istanbul ignore if */\n        if (!typeRefRe.test(token = next()))\n            throw illegal(token);\n\n        responseType = token;\n        skip(\")\");\n\n        var method = new Method(name, type, requestType, responseType, requestStream, responseStream);\n        ifBlock(method, function parseMethod_block(token) {\n\n            /* istanbul ignore else */\n            if (token === \"option\") {\n                parseOption(method, token);\n                skip(\";\");\n            } else\n                throw illegal(token);\n\n        });\n        parent.add(method);\n    }\n\n    function parseExtension(parent, token) {\n\n        /* istanbul ignore if */\n        if (!typeRefRe.test(token = next()))\n            throw illegal(token, \"reference\");\n\n        var reference = token;\n        ifBlock(null, function parseExtension_block(token) {\n            switch (token) {\n\n                case \"required\":\n                case \"repeated\":\n                case \"optional\":\n                    parseField(parent, token, reference);\n                    break;\n\n                default:\n                    /* istanbul ignore if */\n                    if (!isProto3 || !typeRefRe.test(token))\n                        throw illegal(token);\n                    push(token);\n                    parseField(parent, \"optional\", reference);\n                    break;\n            }\n        });\n    }\n\n    var token;\n    while ((token = next()) !== null) {\n        switch (token) {\n\n            case \"package\":\n\n                /* istanbul ignore if */\n                if (!head)\n                    throw illegal(token);\n\n                parsePackage();\n                break;\n\n            case \"import\":\n\n                /* istanbul ignore if */\n                if (!head)\n                    throw illegal(token);\n\n                parseImport();\n                break;\n\n            case \"syntax\":\n\n                /* istanbul ignore if */\n                if (!head)\n                    throw illegal(token);\n\n                parseSyntax();\n                break;\n\n            case \"option\":\n\n                /* istanbul ignore if */\n                if (!head)\n                    throw illegal(token);\n\n                parseOption(ptr, token);\n                skip(\";\");\n                break;\n\n            default:\n\n                /* istanbul ignore else */\n                if (parseCommon(ptr, token)) {\n                    head = false;\n                    continue;\n                }\n\n                /* istanbul ignore next */\n                throw illegal(token);\n        }\n    }\n\n    parse.filename = null;\n    return {\n        \"package\"     : pkg,\n        \"imports\"     : imports,\n        weakImports  : weakImports,\n        syntax       : syntax,\n        root         : root\n    };\n}\n\n/**\n * Parses the given .proto source and returns an object with the parsed contents.\n * @name parse\n * @function\n * @param {string} source Source contents\n * @param {IParseOptions} [options] Parse options. Defaults to {@link parse.defaults} when omitted.\n * @returns {IParserResult} Parser result\n * @property {string} filename=null Currently processing file name for error reporting, if known\n * @property {IParseOptions} defaults Default {@link IParseOptions}\n * @variation 2\n */\nparse._configure = function (){\n    tokenize  = require(28),\n        Root      = require(24),\n        Type      = require(29),\n        Field     = require(10),\n        MapField  = require(14),\n        OneOf     = require(19),\n        Enum      = require(9),\n        Service   = require(27),\n        Method    = require(16),\n        types     = require(30),\n        util      = require(32);\n}","var path = module.exports;\n\nvar isAbsolute =\n/**\n * Tests if the specified path is absolute.\n * @param {string} path Path to test\n * @returns {boolean} `true` if path is absolute\n */\n    path.isAbsolute = function isAbsolute(path) {\n        return /^(?:\\/|\\w+:)/.test(path);\n    };\n\nvar normalize =\n/**\n * Normalizes the specified path.\n * @param {string} path Path to normalize\n * @returns {string} Normalized path\n */\n    path.normalize = function normalize(path) {\n        path = path.replace(/\\\\/g, \"/\")\n            .replace(/\\/{2,}/g, \"/\");\n        var parts    = path.split(\"/\"),\n            absolute = isAbsolute(path),\n            prefix   = \"\";\n        if (absolute)\n            prefix = parts.shift() + \"/\";\n        for (var i = 0; i < parts.length;) {\n            if (parts[i] === \"..\") {\n                if (i > 0 && parts[i - 1] !== \"..\")\n                    parts.splice(--i, 2);\n                else if (absolute)\n                    parts.splice(i, 1);\n                else\n                    ++i;\n            } else if (parts[i] === \".\")\n                parts.splice(i, 1);\n            else\n                ++i;\n        }\n        return prefix + parts.join(\"/\");\n    };\n\n/**\n * Resolves the specified include path against the specified origin path.\n * @param {string} originPath Path to the origin file\n * @param {string} includePath Include path relative to origin path\n * @param {boolean} [alreadyNormalized=false] `true` if both paths are already known to be normalized\n * @returns {string} Path to the include file\n */\npath.resolve = function resolve(originPath, includePath, alreadyNormalized) {\n    if (!alreadyNormalized)\n        includePath = normalize(includePath);\n    if (isAbsolute(includePath))\n        return includePath;\n    if (!alreadyNormalized)\n        originPath = normalize(originPath);\n    return (originPath = originPath.replace(/(?:\\/|^)[^/]+$/, \"\")).length ? normalize(originPath + \"/\" + includePath) : includePath;\n};\n","module.exports = pool;\n\n/**\n * An allocator as used by {@link util.pool}.\n * @typedef PoolAllocator\n * @type {function}\n * @param {number} size Buffer size\n * @returns {Uint8Array} Buffer\n */\n\n/**\n * A slicer as used by {@link util.pool}.\n * @typedef PoolSlicer\n * @type {function}\n * @param {number} start Start offset\n * @param {number} end End offset\n * @returns {Uint8Array} Buffer slice\n * @this {Uint8Array}\n */\n\n/**\n * A general purpose buffer pool.\n * @memberof util\n * @function\n * @param {PoolAllocator} alloc Allocator\n * @param {PoolSlicer} slice Slicer\n * @param {number} [size=8192] Slab size\n * @returns {PoolAllocator} Pooled allocator\n */\nfunction pool(alloc, slice, size) {\n    var SIZE   = size || 8192;\n    var MAX    = SIZE >>> 1;\n    var slab   = null;\n    var offset = SIZE;\n    return function pool_alloc(size) {\n        if (size < 1 || size > MAX)\n            return alloc(size);\n        if (offset + size > SIZE) {\n            slab = alloc(SIZE);\n            offset = 0;\n        }\n        var buf = slice.call(slab, offset, offset += size);\n        if (offset & 7) // align to 32 bit\n            offset = (offset | 7) + 1;\n        return buf;\n    };\n}","/**\n * Created by zhangmiao on 2018/3/13.\n */\n\nmodule.exports = Reader;\n\nvar  util = require(32);\n\nvar LongBits;\nvar utf8;\n\nvar  BufferReader;\n\nfunction indexOutOfRange(reader, writeLength) {\n    return RangeError(\"index out of range: \" + reader.pos + \" + \" + (writeLength || 1) + \" > \" + reader.len);\n}\n\n\nfunction Reader(buffer) {\n\n    /**\n     * Read buffer.\n     * @type {Uint8Array}\n     */\n    this.buf = buffer;\n\n    /**\n     * Read buffer position.\n     * @type {number}\n     */\n    this.pos = 0;\n\n    /**\n     * Read buffer length.\n     * @type {number}\n     */\n    this.len = buffer.length;\n}\n\nvar create_array = typeof Uint8Array !== \"undefined\"\n    ? function create_typed_array(buffer) {\n    if (buffer instanceof Uint8Array || Array.isArray(buffer))\n        return new Reader(buffer);\n    if (typeof ArrayBuffer !== \"undefined\" && buffer instanceof ArrayBuffer) //ArrayBuffer\n        return new Reader(new Uint8Array(buffer));\n    throw Error(\"illegal buffer\");\n}\n    /* istanbul ignore next */\n    : function create_array(buffer) {\n    if (Array.isArray(buffer))\n        return new Reader(buffer);\n    throw Error(\"illegal buffer\");\n};\n\nReader.create = util.Buffer\n    ? function create_buffer_setup(buffer) {\n    return (Reader.create = function create_buffer(buffer) {\n        return util.Buffer.isBuffer(buffer)\n            ? new BufferReader(buffer)\n            /* istanbul ignore next */\n            : create_array(buffer);\n    })(buffer);\n}\n    /* istanbul ignore next */\n    : create_array;\n\nReader.prototype._slice = util.Array.prototype.subarray || /* istanbul ignore next */ util.Array.prototype.slice;\n\n\nReader.prototype.uint32 = (function read_uint32_setup() {\n    var value = 4294967295; // optimizer type-hint, tends to deopt otherwise (?!)\n    return function read_uint32() {\n        value = (         this.buf[this.pos] & 127       ) >>> 0; if (this.buf[this.pos++] < 128) return value;\n        value = (value | (this.buf[this.pos] & 127) <<  7) >>> 0; if (this.buf[this.pos++] < 128) return value;\n        value = (value | (this.buf[this.pos] & 127) << 14) >>> 0; if (this.buf[this.pos++] < 128) return value;\n        value = (value | (this.buf[this.pos] & 127) << 21) >>> 0; if (this.buf[this.pos++] < 128) return value;\n        value = (value | (this.buf[this.pos] &  15) << 28) >>> 0; if (this.buf[this.pos++] < 128) return value;\n\n        /* istanbul ignore if */\n        if ((this.pos += 5) > this.len) {\n            this.pos = this.len;\n            throw indexOutOfRange(this, 10);\n        }\n        return value;\n    };\n})();\n\nReader.prototype.int32 = function read_int32() {\n    return this.uint32() | 0;\n};\n\nReader.prototype.sint32 = function read_sint32() {\n    var value = this.uint32();\n    return value >>> 1 ^ -(value & 1) | 0;\n};\n\nfunction readLongVarint() {\n    // tends to deopt with local vars for octet etc.\n    var bits = new LongBits(0, 0);\n    var i = 0;\n    if (this.len - this.pos > 4) { // fast route (lo)\n        for (; i < 4; ++i) {\n            // 1st..4th\n            bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;\n            if (this.buf[this.pos++] < 128)\n                return bits;\n        }\n        // 5th\n        bits.lo = (bits.lo | (this.buf[this.pos] & 127) << 28) >>> 0;\n        bits.hi = (bits.hi | (this.buf[this.pos] & 127) >>  4) >>> 0;\n        if (this.buf[this.pos++] < 128)\n            return bits;\n        i = 0;\n    } else {\n        for (; i < 3; ++i) {\n            /* istanbul ignore if */\n            if (this.pos >= this.len)\n                throw indexOutOfRange(this);\n            // 1st..3th\n            bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;\n            if (this.buf[this.pos++] < 128)\n                return bits;\n        }\n        // 4th\n        bits.lo = (bits.lo | (this.buf[this.pos++] & 127) << i * 7) >>> 0;\n        return bits;\n    }\n    if (this.len - this.pos > 4) { // fast route (hi)\n        for (; i < 5; ++i) {\n            // 6th..10th\n            bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;\n            if (this.buf[this.pos++] < 128)\n                return bits;\n        }\n    } else {\n        for (; i < 5; ++i) {\n            /* istanbul ignore if */\n            if (this.pos >= this.len)\n                throw indexOutOfRange(this);\n            // 6th..10th\n            bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;\n            if (this.buf[this.pos++] < 128)\n                return bits;\n        }\n    }\n    /* istanbul ignore next */\n    throw Error(\"invalid varint encoding\");\n}\n\nReader.prototype.bool = function read_bool() {\n    return this.uint32() !== 0;\n};\n\n\nfunction readFixed32_end(buf, end) { // note that this uses `end`, not `pos`\n    return (buf[end - 4]\n        | buf[end - 3] << 8\n        | buf[end - 2] << 16\n        | buf[end - 1] << 24) >>> 0;\n}\n\nReader.prototype.fixed32 = function read_fixed32() {\n\n    /* istanbul ignore if */\n    if (this.pos + 4 > this.len)\n        throw indexOutOfRange(this, 4);\n\n    return readFixed32_end(this.buf, this.pos += 4);\n};\n\nReader.prototype.sfixed32 = function read_sfixed32() {\n\n    /* istanbul ignore if */\n    if (this.pos + 4 > this.len)\n        throw indexOutOfRange(this, 4);\n\n    return readFixed32_end(this.buf, this.pos += 4) | 0;\n};\n\n/* eslint-disable no-invalid-this */\n\nfunction readFixed64(/* this: Reader */) {\n\n    /* istanbul ignore if */\n    if (this.pos + 8 > this.len)\n        throw indexOutOfRange(this, 8);\n\n    return new LongBits(readFixed32_end(this.buf, this.pos += 4), readFixed32_end(this.buf, this.pos += 4));\n}\n\n\nReader.prototype.float = function read_float() {\n\n    /* istanbul ignore if */\n    if (this.pos + 4 > this.len)\n        throw indexOutOfRange(this, 4);\n\n    var value = util.float.readFloatLE(this.buf, this.pos);\n    this.pos += 4;\n    return value;\n};\n\nReader.prototype.double = function read_double() {\n\n    /* istanbul ignore if */\n    if (this.pos + 8 > this.len)\n        throw indexOutOfRange(this, 4);\n\n    var value = util.float.readDoubleLE(this.buf, this.pos);\n    this.pos += 8;\n    return value;\n};\n\nReader.prototype.bytes = function read_bytes() {\n    var length = this.uint32(),\n        start  = this.pos,\n        end    = this.pos + length;\n\n    /* istanbul ignore if */\n    if (end > this.len)\n        throw indexOutOfRange(this, length);\n    this.pos += length;\n    if (Array.isArray(this.buf)) // plain array\n        return this.buf.slice(start, end);\n    return start === end // fix for IE 10/Win8 and others' subarray returning array of size 1\n        ? new this.buf.constructor(0)\n        : this._slice.call(this.buf, start, end);\n};\n\nReader.prototype.string = function read_string() {\n    var bytes = this.bytes();\n    return utf8.read(bytes, 0, bytes.length);\n};\n\nReader.prototype.skip = function skip(length) {\n    if (typeof length === \"number\") {\n        /* istanbul ignore if */\n        if (this.pos + length > this.len)\n            throw indexOutOfRange(this, length);\n        this.pos += length;\n    } else {\n        do {\n            /* istanbul ignore if */\n            if (this.pos >= this.len)\n                throw indexOutOfRange(this);\n        } while (this.buf[this.pos++] & 128);\n    }\n    return this;\n};\n\nReader.prototype.skipType = function(wireType) {\n    switch (wireType) {\n        case 0:\n            this.skip();\n            break;\n        case 1:\n            this.skip(8);\n            break;\n        case 2:\n            this.skip(this.uint32());\n            break;\n        case 3:\n            do { // eslint-disable-line no-constant-condition\n                if ((wireType = this.uint32() & 7) === 4)\n                    break;\n                this.skipType(wireType);\n            } while (true);\n            break;\n        case 5:\n            this.skip(4);\n            break;\n\n        /* istanbul ignore next */\n        default:\n            throw Error(\"invalid wire type \" + wireType + \" at offset \" + this.pos);\n    }\n    return this;\n};\n\n\n\n//\nReader._configure = function() {\n\n    //util       = require('./util');\n    LongBits = require(13);\n    utf8     = require(31);\n\n    var fn = util.Long ? \"toLong\" : /* istanbul ignore next */ \"toNumber\";\n    util.merge(Reader.prototype, {\n\n        int64: function read_int64() {\n            return readLongVarint.call(this)[fn](false);\n        },\n\n        uint64: function read_uint64() {\n            return readLongVarint.call(this)[fn](true);\n        },\n\n        sint64: function read_sint64() {\n            return readLongVarint.call(this).zzDecode()[fn](false);\n        },\n\n        fixed64: function read_fixed64() {\n            return readFixed64.call(this)[fn](true);\n        },\n\n        sfixed64: function read_sfixed64() {\n            return readFixed64.call(this)[fn](false);\n        }\n\n    });\n};\n\n","module.exports = Root;\n\n// extends Namespace\nvar Namespace = require(17);\n((Root.prototype = Object.create(Namespace.prototype)).constructor = Root).className = \"Root\";\n\nvar Field   = require(10),\n    Enum    = require(9),\n    OneOf   = require(19),\n    util    = require(32);\n\nvar Type,   // cyclic\n    parse,  // might be excluded\n    common; // \"\n\n/**\n * Constructs a new root namespace instance.\n * @classdesc Root namespace wrapping all types, enums, services, sub-namespaces etc. that belong together.\n * @extends NamespaceBase\n * @constructor\n * @param {Object.<string,*>} [options] Top level options\n */\nfunction Root(options) {\n    Namespace.call(this, \"\", options);\n\n    /**\n     * Deferred extension fields.\n     * @type {Field[]}\n     */\n    this.deferred = [];\n\n    /**\n     * Resolved file names of loaded files.\n     * @type {string[]}\n     */\n    this.files = [];\n\n    /**\n     * Resolved name of parsered pbString.\n     * @type {string[]}\n     */\n    this.names = [];\n}\n\n/**\n * Loads a namespace descriptor into a root namespace.\n * @param {INamespace} json Nameespace descriptor\n * @param {Root} [root] Root namespace, defaults to create a new one if omitted\n * @returns {Root} Root namespace\n */\nRoot.fromJSON = function fromJSON(json, root) {\n    json = typeof json === 'string' ? JSON.parse(json) : json;\n    if (!root)\n        root = new Root();\n    if (json.options)\n        root.setOptions(json.options);\n    return root.addJSON(json.nested);\n};\n\n/**\n * Resolves the path of an imported file, relative to the importing origin.\n * This method exists so you can override it with your own logic in case your imports are scattered over multiple directories.\n * @function\n * @param {string} origin The file name of the importing file\n * @param {string} target The file name being imported\n * @returns {string|null} Resolved path to `target` or `null` to skip the file\n */\nRoot.prototype.resolvePath = util.path.resolve;\n\n// A symbol-like function to safely signal synchronous loading\n/* istanbul ignore next */\nfunction SYNC() {} // eslint-disable-line no-empty-function\n\nfunction parseFromPbString(pbString, options, callback){\n\n    if (typeof options === \"function\") {\n        callback = options;\n        options = undefined;\n    }\n    var self = this;\n    if (!callback){\n        return util.asPromise(parseFromPbString, self, pbString, options);\n    }\n\n    var pbObj = null;\n    if(typeof pbString === 'string'){\n        pbObj = JSON.parse(pbString);\n    }else if(typeof pbString === 'object'){\n        pbObj = pbString;\n    }else {\n        //throw Error(\"pb\");\n        console.log(\"pb\");\n        return undefined;\n    }\n\n    var name      = pbObj['name'];\n    var pbJsonStr = pbObj['pbJsonStr'];\n\n    function finish(err, root){\n        if(!callback)\n            return;\n        var cb = callback;\n        callback = null;\n        cb(err, root);\n    }\n\n    function process(name, source){\n        try {\n            if (util.isString(source) && source.charAt(0) === \"{\")\n                source = JSON.parse(source);\n            if (!util.isString(source))\n                self.setOptions(source.options).addJSON(source.nested);\n            else {\n                parse.filename = name;\n                var parsed = parse(source, self, options),\n                    resolved;\n                var i = 0;\n                if(parsed.imports){\n                    for (; i < parsed.imports.length; ++i){\n                        resolved = parsed.imports[i];\n                        fetch(resolved);\n                    }\n                }\n                if (parsed.weakImports){\n                    for (i = 0; i < parsed.weakImports.length; ++i)\n                         resolved = parsed.weakImports[i];\n                            fetch(resolved, true);\n                }\n            }\n        } catch (err) {\n            finish(err);\n        }\n\n        finish(null, self); // only once anyway\n    }\n\n    function  fetch(name){\n        if(self.names.indexOf(name)>-1)\n            return;\n        self.names.push(name);\n        if (name in common){\n            process(name, common[name]);\n        }\n    }\n\n    process(name, pbJsonStr);\n    return undefined;\n}\n\nRoot.prototype.parseFromPbString = parseFromPbString;\n\n/**\n * Loads one or multiple .proto or preprocessed .json files into this root namespace and calls the callback.\n * @param {string|string[]} filename Names of one or multiple files to load\n * @param {IParseOptions} options Parse options\n * @param {LoadCallback} callback Callback function\n * @returns {undefined}\n */\nRoot.prototype.load = function load(filename, options, callback) {\n    if (typeof options === \"function\") {\n        callback = options;\n        options = undefined;\n    }\n    var self = this;\n    if (!callback)\n        return util.asPromise(load, self, filename, options);\n\n    var sync = callback === SYNC; // undocumented\n\n    // Finishes loading by calling the callback (exactly once)\n    function finish(err, root) {\n        /* istanbul ignore if */\n        if (!callback)\n            return;\n        var cb = callback;\n        callback = null;\n        if (sync)\n            throw err;\n        cb(err, root);\n    }\n\n    // Processes a single file\n    function process(filename, source) {\n        try {\n            if (util.isString(source) && source.charAt(0) === \"{\")\n                source = JSON.parse(source);\n            if (!util.isString(source))\n                self.setOptions(source.options).addJSON(source.nested);\n            else {\n                parse.filename = filename;\n                var parsed = parse(source, self, options),\n                    resolved,\n                    i = 0;\n                if (parsed.imports)\n                    for (; i < parsed.imports.length; ++i)\n                        if (resolved = self.resolvePath(filename, parsed.imports[i]))\n                            fetch(resolved);\n                if (parsed.weakImports)\n                    for (i = 0; i < parsed.weakImports.length; ++i)\n                        if (resolved = self.resolvePath(filename, parsed.weakImports[i]))\n                            fetch(resolved, true);\n            }\n        } catch (err) {\n            finish(err);\n        }\n        if (!sync && !queued)\n            finish(null, self); // only once anyway\n    }\n\n    // Fetches a single file\n    function fetch(filename, weak) {\n\n        // Strip path if this file references a bundled definition\n        var idx = filename.lastIndexOf(\"google/protobuf/\");\n        if (idx > -1) {\n            var altname = filename.substring(idx);\n            if (altname in common)\n                filename = altname;\n        }\n\n        // Skip if already loaded / attempted\n        if (self.files.indexOf(filename) > -1)\n            return;\n        self.files.push(filename);\n\n        // Shortcut bundled definitions\n        if (filename in common) {\n            if (sync)\n                process(filename, common[filename]);\n            else {\n                ++queued;\n                setTimeout(function() {\n                    --queued;\n                    process(filename, common[filename]);\n                });\n            }\n            return;\n        }\n\n        // Otherwise fetch from disk or network\n        if (sync) {\n            var source;\n            try {\n                source = util.fs.readFileSync(filename).toString(\"utf8\");\n            } catch (err) {\n                if (!weak)\n                    finish(err);\n                return;\n            }\n            process(filename, source);\n        } else {\n            ++queued;\n            util.fetch(filename, function(err, source) {\n                --queued;\n                /* istanbul ignore if */\n                if (!callback)\n                    return; // terminated meanwhile\n                if (err) {\n                    /* istanbul ignore else */\n                    if (!weak)\n                        finish(err);\n                    else if (!queued) // can't be covered reliably\n                        finish(null, self);\n                    return;\n                }\n                process(filename, source);\n            });\n        }\n    }\n    var queued = 0;\n\n    // Assembling the root namespace doesn't require working type\n    // references anymore, so we can load everything in parallel\n    if (util.isString(filename))\n        filename = [ filename ];\n    for (var i = 0, resolved; i < filename.length; ++i)\n        if (resolved = self.resolvePath(\"\", filename[i]))\n            fetch(resolved);\n\n    if (sync)\n        return self;\n    if (!queued)\n        finish(null, self);\n    return undefined;\n};\n// function load(filename:string, options:IParseOptions, callback:LoadCallback):undefined\n\n/**\n * Loads one or multiple .proto or preprocessed .json files into this root namespace and calls the callback.\n * @function Root#load\n * @param {string|string[]} filename Names of one or multiple files to load\n * @param {LoadCallback} callback Callback function\n * @returns {undefined}\n * @variation 2\n */\n// function load(filename:string, callback:LoadCallback):undefined\n\n/**\n * Loads one or multiple .proto or preprocessed .json files into this root namespace and returns a promise.\n * @function Root#load\n * @param {string|string[]} filename Names of one or multiple files to load\n * @param {IParseOptions} [options] Parse options. Defaults to {@link parse.defaults} when omitted.\n * @returns {Promise<Root>} Promise\n * @variation 3\n */\n// function load(filename:string, [options:IParseOptions]):Promise<Root>\n\n/**\n * Synchronously loads one or multiple .proto or preprocessed .json files into this root namespace (node only).\n * @function Root#loadSync\n * @param {string|string[]} filename Names of one or multiple files to load\n * @param {IParseOptions} [options] Parse options. Defaults to {@link parse.defaults} when omitted.\n * @returns {Root} Root namespace\n * @throws {Error} If synchronous fetching is not supported (i.e. in browsers) or if a file's syntax is invalid\n */\nRoot.prototype.loadSync = function loadSync(filename, options) {\n    if (!util.isNode)\n        throw Error(\"not supported\");\n    return this.load(filename, options, SYNC);\n};\n\n/**\n * @override\n */\nRoot.prototype.resolveAll = function resolveAll() {\n    if (this.deferred.length)\n        throw Error(\"unresolvable extensions: \" + this.deferred.map(function(field) {\n                return \"'extend \" + field.extend + \"' in \" + field.parent.fullName;\n            }).join(\", \"));\n    return Namespace.prototype.resolveAll.call(this);\n};\n\n// only uppercased (and thus conflict-free) children are exposed, see below\nvar exposeRe = /^[A-Z]/;\n\n/**\n * Handles a deferred declaring extension field by creating a sister field to represent it within its extended type.\n * @param {Root} root Root instance\n * @param {Field} field Declaring extension field witin the declaring type\n * @returns {boolean} `true` if successfully added to the extended type, `false` otherwise\n * @inner\n * @ignore\n */\nfunction tryHandleExtension(root, field) {\n    var extendedType = field.parent.lookup(field.extend);\n    if (extendedType) {\n        var sisterField = new Field(field.fullName, field.id, field.type, field.rule, undefined, field.options);\n        sisterField.declaringField = field;\n        field.extensionField = sisterField;\n        extendedType.add(sisterField);\n        return true;\n    }\n    return false;\n}\n\n/**\n * Called when any object is added to this root or its sub-namespaces.\n * @param {ReflectionObject} object Object added\n * @returns {undefined}\n * @private\n */\nRoot.prototype._handleAdd = function _handleAdd(object) {\n    if (object instanceof Field) {\n\n        if (/* an extension field (implies not part of a oneof) */ object.extend !== undefined && /* not already handled */ !object.extensionField)\n            if (!tryHandleExtension(this, object))\n                this.deferred.push(object);\n\n    } else if (object instanceof Enum) {\n\n        if (exposeRe.test(object.name))\n            object.parent[object.name] = object.values; // expose enum values as property of its parent\n\n    } else if (!(object instanceof OneOf)) /* everything else is a namespace */ {\n\n        if (object instanceof Type) // Try to handle any deferred extensions\n            for (var i = 0; i < this.deferred.length;)\n                if (tryHandleExtension(this, this.deferred[i]))\n                    this.deferred.splice(i, 1);\n                else\n                    ++i;\n        for (var j = 0; j < /* initializes */ object.nestedArray.length; ++j) // recurse into the namespace\n            this._handleAdd(object._nestedArray[j]);\n        if (exposeRe.test(object.name))\n            object.parent[object.name] = object; // expose namespace as property of its parent\n    }\n\n    // The above also adds uppercased (and thus conflict-free) nested types, services and enums as\n    // properties of namespaces just like static code does. This allows using a .d.ts generated for\n    // a static module with reflection-based solutions where the condition is met.\n};\n\n/**\n * Called when any object is removed from this root or its sub-namespaces.\n * @param {ReflectionObject} object Object removed\n * @returns {undefined}\n * @private\n */\nRoot.prototype._handleRemove = function _handleRemove(object) {\n    if (object instanceof Field) {\n\n        if (/* an extension field */ object.extend !== undefined) {\n            if (/* already handled */ object.extensionField) { // remove its sister field\n                object.extensionField.parent.remove(object.extensionField);\n                object.extensionField = null;\n            } else { // cancel the extension\n                var index = this.deferred.indexOf(object);\n                /* istanbul ignore else */\n                if (index > -1)\n                    this.deferred.splice(index, 1);\n            }\n        }\n\n    } else if (object instanceof Enum) {\n\n        if (exposeRe.test(object.name))\n            delete object.parent[object.name]; // unexpose enum values\n\n    } else if (object instanceof Namespace) {\n\n        for (var i = 0; i < /* initializes */ object.nestedArray.length; ++i) // recurse into the namespace\n            this._handleRemove(object._nestedArray[i]);\n\n        if (exposeRe.test(object.name))\n            delete object.parent[object.name]; // unexpose namespaces\n\n    }\n};\n\nRoot._configure = function() {\n    Type = require(29);\n    parse = require(20);\n    common = require(5);\n\n    Field   = require(10);\n    Enum    = require(9);\n    OneOf   = require(19);\n    util    = require(32);\n};\n","/**\n * Created by zhangmiao on 2018/3/13.\n */\n\n\nmodule.exports = {};","\"use strict\";\nmodule.exports = Service;\nvar util = require(32);\n\n// Extends EventEmitter\n(Service.prototype = Object.create(util.EventEmitter.prototype)).constructor = Service;\n\n/**\n * A service method callback as used by {@link rpc.ServiceMethod|ServiceMethod}.\n *\n * Differs from {@link RPCImplCallback} in that it is an actual callback of a service method which may not return `response = null`.\n * @typedef rpc.ServiceMethodCallback\n * @template TRes extends Message<TRes>\n * @type {function}\n * @param {Error|null} error Error, if any\n * @param {TRes} [response] Response message\n * @returns {undefined}\n */\n\n/**\n * A service method part of a {@link rpc.Service} as created by {@link Service.create}.\n * @typedef rpc.ServiceMethod\n * @template TReq extends Message<TReq>\n * @template TRes extends Message<TRes>\n * @type {function}\n * @param {TReq|Properties<TReq>} request Request message or plain object\n * @param {rpc.ServiceMethodCallback<TRes>} [callback] Node-style callback called with the error, if any, and the response message\n * @returns {Promise<Message<TRes>>} Promise if `callback` has been omitted, otherwise `undefined`\n */\n\n/**\n * Constructs a new RPC service instance.\n * @classdesc An RPC service as returned by {@link Service#create}.\n * @exports rpc.Service\n * @extends util.EventEmitter\n * @constructor\n * @param {RPCImpl} rpcImpl RPC implementation\n * @param {boolean} [requestDelimited=false] Whether requests are length-delimited\n * @param {boolean} [responseDelimited=false] Whether responses are length-delimited\n */\nfunction Service(rpcImpl, requestDelimited, responseDelimited) {\n\n    if (typeof rpcImpl !== \"function\")\n        throw TypeError(\"rpcImpl must be a function\");\n\n    util.EventEmitter.call(this);\n\n    /**\n     * RPC implementation. Becomes `null` once the service is ended.\n     * @type {RPCImpl|null}\n     */\n    this.rpcImpl = rpcImpl;\n\n    /**\n     * Whether requests are length-delimited.\n     * @type {boolean}\n     */\n    this.requestDelimited = Boolean(requestDelimited);\n\n    /**\n     * Whether responses are length-delimited.\n     * @type {boolean}\n     */\n    this.responseDelimited = Boolean(responseDelimited);\n}\n\n/**\n * Calls a service method through {@link rpc.Service#rpcImpl|rpcImpl}.\n * @param {Method|rpc.ServiceMethod<TReq,TRes>} method Reflected or static method\n * @param {Constructor<TReq>} requestCtor Request constructor\n * @param {Constructor<TRes>} responseCtor Response constructor\n * @param {TReq|Properties<TReq>} request Request message or plain object\n * @param {rpc.ServiceMethodCallback<TRes>} callback Service callback\n * @returns {undefined}\n * @template TReq extends Message<TReq>\n * @template TRes extends Message<TRes>\n */\nService.prototype.rpcCall = function rpcCall(method, requestCtor, responseCtor, request, callback) {\n\n    if (!request)\n        throw TypeError(\"request must be specified\");\n\n    var self = this;\n    if (!callback)\n        return util.asPromise(rpcCall, self, method, requestCtor, responseCtor, request);\n\n    if (!self.rpcImpl) {\n        setTimeout(function() { callback(Error(\"already ended\")); }, 0);\n        return undefined;\n    }\n\n    try {\n        return self.rpcImpl(\n            method,\n            requestCtor[self.requestDelimited ? \"encodeDelimited\" : \"encode\"](request).finish(),\n            function rpcCallback(err, response) {\n\n                if (err) {\n                    self.emit(\"error\", err, method);\n                    return callback(err);\n                }\n\n                if (response === null) {\n                    self.end(/* endedByRPC */ true);\n                    return undefined;\n                }\n\n                if (!(response instanceof responseCtor)) {\n                    try {\n                        response = responseCtor[self.responseDelimited ? \"decodeDelimited\" : \"decode\"](response);\n                    } catch (err) {\n                        self.emit(\"error\", err, method);\n                        return callback(err);\n                    }\n                }\n\n                self.emit(\"data\", response, method);\n                return callback(null, response);\n            }\n        );\n    } catch (err) {\n        self.emit(\"error\", err, method);\n        setTimeout(function() { callback(err); }, 0);\n        return undefined;\n    }\n};\n\n/**\n * Ends this service and emits the `end` event.\n * @param {boolean} [endedByRPC=false] Whether the service has been ended by the RPC implementation.\n * @returns {rpc.Service} `this`\n */\nService.prototype.end = function end(endedByRPC) {\n    if (this.rpcImpl) {\n        if (!endedByRPC) // signal end to rpcImpl\n            this.rpcImpl(null, null, null);\n        this.rpcImpl = null;\n        this.emit(\"end\").off();\n    }\n    return this;\n};\n","\"use strict\";\nmodule.exports = Service;\n\n// extends Namespace\nvar Namespace = require(17);\n((Service.prototype = Object.create(Namespace.prototype)).constructor = Service).className = \"Service\";\n\nvar Method,\n    util,\n    rpc;\n\n/**\n * Constructs a new service instance.\n * @classdesc Reflected service.\n * @extends NamespaceBase\n * @constructor\n * @param {string} name Service name\n * @param {Object.<string,*>} [options] Service options\n * @throws {TypeError} If arguments are invalid\n */\nfunction Service(name, options) {\n    Namespace.call(this, name, options);\n\n    /**\n     * Service methods.\n     * @type {Object.<string,Method>}\n     */\n    this.methods = {}; // toJSON, marker\n\n    /**\n     * Cached methods as an array.\n     * @type {Method[]|null}\n     * @private\n     */\n    this._methodsArray = null;\n}\n\n/**\n * Service descriptor.\n * @interface IService\n * @extends INamespace\n * @property {Object.<string,IMethod>} methods Method descriptors\n */\n\n/**\n * Constructs a service from a service descriptor.\n * @param {string} name Service name\n * @param {IService} json Service descriptor\n * @returns {Service} Created service\n * @throws {TypeError} If arguments are invalid\n */\nService.fromJSON = function fromJSON(name, json) {\n    var service = new Service(name, json.options);\n    /* istanbul ignore else */\n    if (json.methods)\n        for (var names = Object.keys(json.methods), i = 0; i < names.length; ++i)\n            service.add(Method.fromJSON(names[i], json.methods[names[i]]));\n    if (json.nested)\n        service.addJSON(json.nested);\n    service.comment = json.comment;\n    return service;\n};\n\n/**\n * Converts this service to a service descriptor.\n * @param {IToJSONOptions} [toJSONOptions] JSON conversion options\n * @returns {IService} Service descriptor\n */\nService.prototype.toJSON = function toJSON(toJSONOptions) {\n    var inherited = Namespace.prototype.toJSON.call(this, toJSONOptions);\n    var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;\n    return util.toObject([\n        \"options\" , inherited && inherited.options || undefined,\n        \"methods\" , Namespace.arrayToJSON(this.methodsArray, toJSONOptions) || /* istanbul ignore next */ {},\n        \"nested\"  , inherited && inherited.nested || undefined,\n        \"comment\" , keepComments ? this.comment : undefined\n    ]);\n};\n\n/**\n * Methods of this service as an array for iteration.\n * @name Service#methodsArray\n * @type {Method[]}\n * @readonly\n */\nObject.defineProperty(Service.prototype, \"methodsArray\", {\n    get: function() {\n        return this._methodsArray || (this._methodsArray = util.toArray(this.methods));\n    }\n});\n\nfunction clearCache(service) {\n    service._methodsArray = null;\n    return service;\n}\n\n/**\n * @override\n */\nService.prototype.get = function get(name) {\n    return this.methods[name]\n        || Namespace.prototype.get.call(this, name);\n};\n\n/**\n * @override\n */\nService.prototype.resolveAll = function resolveAll() {\n    var methods = this.methodsArray;\n    for (var i = 0; i < methods.length; ++i)\n        methods[i].resolve();\n    return Namespace.prototype.resolve.call(this);\n};\n\n/**\n * @override\n */\nService.prototype.add = function add(object) {\n\n    /* istanbul ignore if */\n    if (this.get(object.name))\n        throw Error(\"duplicate name '\" + object.name + \"' in \" + this);\n\n    if (object instanceof Method) {\n        this.methods[object.name] = object;\n        object.parent = this;\n        return clearCache(this);\n    }\n    return Namespace.prototype.add.call(this, object);\n};\n\n/**\n * @override\n */\nService.prototype.remove = function remove(object) {\n    if (object instanceof Method) {\n\n        /* istanbul ignore if */\n        if (this.methods[object.name] !== object)\n            throw Error(object + \" is not a member of \" + this);\n\n        delete this.methods[object.name];\n        object.parent = null;\n        return clearCache(this);\n    }\n    return Namespace.prototype.remove.call(this, object);\n};\n\n/**\n * Creates a runtime service using the specified rpc implementation.\n * @param {RPCImpl} rpcImpl RPC implementation\n * @param {boolean} [requestDelimited=false] Whether requests are length-delimited\n * @param {boolean} [responseDelimited=false] Whether responses are length-delimited\n * @returns {rpc.Service} RPC service. Useful where requests and/or responses are streamed.\n */\nService.prototype.create = function create(rpcImpl, requestDelimited, responseDelimited) {\n    var rpcService = new rpc.Service(rpcImpl, requestDelimited, responseDelimited);\n    for (var i = 0, method; i < /* initializes */ this.methodsArray.length; ++i) {\n        var methodName = util.lcFirst((method = this._methodsArray[i]).resolve().name).replace(/[^$\\w_]/g, \"\");\n        rpcService[methodName] = util.codegen([\"r\",\"c\"], util.isReserved(methodName) ? methodName + \"_\" : methodName)(\"return this.rpcCall(m,q,s,r,c)\")({\n            m: method,\n            q: method.resolvedRequestType.ctor,\n            s: method.resolvedResponseType.ctor\n        });\n    }\n    return rpcService;\n};\n\nService._configure = function (){\n    Method = require(16);\n    util   = require(32);\n    rpc    = require(26);\n};","module.exports = tokenize;\n\nvar delimRe        = /[\\s{}=;:[\\],'\"()<>]/g,\n    stringDoubleRe = /(?:\"([^\"\\\\]*(?:\\\\.[^\"\\\\]*)*)\")/g,\n    stringSingleRe = /(?:'([^'\\\\]*(?:\\\\.[^'\\\\]*)*)')/g;\n\nvar setCommentRe = /^ *[*/]+ */,\n    setCommentAltRe = /^\\s*\\*?\\/*/,\n    setCommentSplitRe = /\\n/g,\n    whitespaceRe = /\\s/,\n    unescapeRe = /\\\\(.?)/g;\n\nvar unescapeMap = {\n    \"0\": \"\\0\",\n    \"r\": \"\\r\",\n    \"n\": \"\\n\",\n    \"t\": \"\\t\"\n};\n\n/**\n * Unescapes a string.\n * @param {string} str String to unescape\n * @returns {string} Unescaped string\n * @property {Object.<string,string>} map Special characters map\n * @memberof tokenize\n */\nfunction unescape(str) {\n    return str.replace(unescapeRe, function($0, $1) {\n        switch ($1) {\n            case \"\\\\\":\n            case \"\":\n                return $1;\n            default:\n                return unescapeMap[$1] || \"\";\n        }\n    });\n}\n\ntokenize.unescape = unescape;\n\n/**\n * Gets the next token and advances.\n * @typedef TokenizerHandleNext\n * @type {function}\n * @returns {string|null} Next token or `null` on eof\n */\n\n/**\n * Peeks for the next token.\n * @typedef TokenizerHandlePeek\n * @type {function}\n * @returns {string|null} Next token or `null` on eof\n */\n\n/**\n * Pushes a token back to the stack.\n * @typedef TokenizerHandlePush\n * @type {function}\n * @param {string} token Token\n * @returns {undefined}\n */\n\n/**\n * Skips the next token.\n * @typedef TokenizerHandleSkip\n * @type {function}\n * @param {string} expected Expected token\n * @param {boolean} [optional=false] If optional\n * @returns {boolean} Whether the token matched\n * @throws {Error} If the token didn't match and is not optional\n */\n\n/**\n * Gets the comment on the previous line or, alternatively, the line comment on the specified line.\n * @typedef TokenizerHandleCmnt\n * @type {function}\n * @param {number} [line] Line number\n * @returns {string|null} Comment text or `null` if none\n */\n\n/**\n * Handle object returned from {@link tokenize}.\n * @interface ITokenizerHandle\n * @property {TokenizerHandleNext} next Gets the next token and advances (`null` on eof)\n * @property {TokenizerHandlePeek} peek Peeks for the next token (`null` on eof)\n * @property {TokenizerHandlePush} push Pushes a token back to the stack\n * @property {TokenizerHandleSkip} skip Skips a token, returns its presence and advances or, if non-optional and not present, throws\n * @property {TokenizerHandleCmnt} cmnt Gets the comment on the previous line or the line comment on the specified line, if any\n * @property {number} line Current line number\n */\n\n/**\n * Tokenizes the given .proto source and returns an object with useful utility functions.\n * @param {string} source Source contents\n * @param {boolean} alternateCommentMode Whether we should activate alternate comment parsing mode.\n * @returns {ITokenizerHandle} Tokenizer handle\n */\nfunction tokenize(source, alternateCommentMode) {\n    /* eslint-disable callback-return */\n    source = source.toString();\n\n    var offset = 0,\n        length = source.length,\n        line = 1,\n        commentType = null,\n        commentText = null,\n        commentLine = 0,\n        commentLineEmpty = false;\n\n    var stack = [];\n\n    var stringDelim = null;\n\n    /* istanbul ignore next */\n    /**\n     * Creates an error for illegal syntax.\n     * @param {string} subject Subject\n     * @returns {Error} Error created\n     * @inner\n     */\n    function illegal(subject) {\n        return Error(\"illegal \" + subject + \" (line \" + line + \")\");\n    }\n\n    /**\n     * Reads a string till its end.\n     * @returns {string} String read\n     * @inner\n     */\n    function readString() {\n        var re = stringDelim === \"'\" ? stringSingleRe : stringDoubleRe;\n        re.lastIndex = offset - 1;\n        var match = re.exec(source);\n        if (!match)\n            throw illegal(\"string\");\n        offset = re.lastIndex;\n        push(stringDelim);\n        stringDelim = null;\n        return unescape(match[1]);\n    }\n\n    /**\n     * Gets the character at `pos` within the source.\n     * @param {number} pos Position\n     * @returns {string} Character\n     * @inner\n     */\n    function charAt(pos) {\n        return source.charAt(pos);\n    }\n\n    /**\n     * Sets the current comment text.\n     * @param {number} start Start offset\n     * @param {number} end End offset\n     * @returns {undefined}\n     * @inner\n     */\n    function setComment(start, end) {\n        commentType = source.charAt(start++);\n        commentLine = line;\n        commentLineEmpty = false;\n        var lookback;\n        if (alternateCommentMode) {\n            lookback = 2;  // alternate comment parsing: \"//\" or \"/*\"\n        } else {\n            lookback = 3;  // \"///\" or \"/**\"\n        }\n        var commentOffset = start - lookback,\n            c;\n        do {\n            if (--commentOffset < 0 ||\n                (c = source.charAt(commentOffset)) === \"\\n\") {\n                commentLineEmpty = true;\n                break;\n            }\n        } while (c === \" \" || c === \"\\t\");\n        var lines = source\n            .substring(start, end)\n            .split(setCommentSplitRe);\n        for (var i = 0; i < lines.length; ++i)\n            lines[i] = lines[i]\n                .replace(alternateCommentMode ? setCommentAltRe : setCommentRe, \"\")\n                .trim();\n        commentText = lines\n            .join(\"\\n\")\n            .trim();\n    }\n\n    function isDoubleSlashCommentLine(startOffset) {\n        var endOffset = findEndOfLine(startOffset);\n\n        // see if remaining line matches comment pattern\n        var lineText = source.substring(startOffset, endOffset);\n        // look for 1 or 2 slashes since startOffset would already point past\n        // the first slash that started the comment.\n        var isComment = /^\\s*\\/{1,2}/.test(lineText);\n        return isComment;\n    }\n\n    function findEndOfLine(cursor) {\n        // find end of cursor's line\n        var endOffset = cursor;\n        while (endOffset < length && charAt(endOffset) !== \"\\n\") {\n            endOffset++;\n        }\n        return endOffset;\n    }\n\n    /**\n     * Obtains the next token.\n     * @returns {string|null} Next token or `null` on eof\n     * @inner\n     */\n    function next() {\n        if (stack.length > 0)\n            return stack.shift();\n        if (stringDelim)\n            return readString();\n        var repeat,\n            prev,\n            curr,\n            start,\n            isDoc;\n        do {\n            if (offset === length)\n                return null;\n            repeat = false;\n            while (whitespaceRe.test(curr = charAt(offset))) {\n                if (curr === \"\\n\")\n                    ++line;\n                if (++offset === length)\n                    return null;\n            }\n\n            if (charAt(offset) === \"/\") {\n                if (++offset === length) {\n                    throw illegal(\"comment\");\n                }\n                if (charAt(offset) === \"/\") { // Line\n                    if (!alternateCommentMode) {\n                        // check for triple-slash comment\n                        isDoc = charAt(start = offset + 1) === \"/\";\n\n                        while (charAt(++offset) !== \"\\n\") {\n                            if (offset === length) {\n                                return null;\n                            }\n                        }\n                        ++offset;\n                        if (isDoc) {\n                            setComment(start, offset - 1);\n                        }\n                        ++line;\n                        repeat = true;\n                    } else {\n                        // check for double-slash comments, consolidating consecutive lines\n                        start = offset;\n                        isDoc = false;\n                        if (isDoubleSlashCommentLine(offset)) {\n                            isDoc = true;\n                            do {\n                                offset = findEndOfLine(offset);\n                                if (offset === length) {\n                                    break;\n                                }\n                                offset++;\n                            } while (isDoubleSlashCommentLine(offset));\n                        } else {\n                            offset = Math.min(length, findEndOfLine(offset) + 1);\n                        }\n                        if (isDoc) {\n                            setComment(start, offset);\n                        }\n                        line++;\n                        repeat = true;\n                    }\n                } else if ((curr = charAt(offset)) === \"*\") { /* Block */\n                    // check for /** (regular comment mode) or /* (alternate comment mode)\n                    start = offset + 1;\n                    isDoc = alternateCommentMode || charAt(start) === \"*\";\n                    do {\n                        if (curr === \"\\n\") {\n                            ++line;\n                        }\n                        if (++offset === length) {\n                            throw illegal(\"comment\");\n                        }\n                        prev = curr;\n                        curr = charAt(offset);\n                    } while (prev !== \"*\" || curr !== \"/\");\n                    ++offset;\n                    if (isDoc) {\n                        setComment(start, offset - 2);\n                    }\n                    repeat = true;\n                } else {\n                    return \"/\";\n                }\n            }\n        } while (repeat);\n\n        // offset !== length if we got here\n\n        var end = offset;\n        delimRe.lastIndex = 0;\n        var delim = delimRe.test(charAt(end++));\n        if (!delim)\n            while (end < length && !delimRe.test(charAt(end)))\n                ++end;\n        var token = source.substring(offset, offset = end);\n        if (token === \"\\\"\" || token === \"'\")\n            stringDelim = token;\n        return token;\n    }\n\n    /**\n     * Pushes a token back to the stack.\n     * @param {string} token Token\n     * @returns {undefined}\n     * @inner\n     */\n    function push(token) {\n        stack.push(token);\n    }\n\n    /**\n     * Peeks for the next token.\n     * @returns {string|null} Token or `null` on eof\n     * @inner\n     */\n    function peek() {\n        if (!stack.length) {\n            var token = next();\n            if (token === null)\n                return null;\n            push(token);\n        }\n        return stack[0];\n    }\n\n    /**\n     * Skips a token.\n     * @param {string} expected Expected token\n     * @param {boolean} [optional=false] Whether the token is optional\n     * @returns {boolean} `true` when skipped, `false` if not\n     * @throws {Error} When a required token is not present\n     * @inner\n     */\n    function skip(expected, optional) {\n        var actual = peek(),\n            equals = actual === expected;\n        if (equals) {\n            next();\n            return true;\n        }\n        if (!optional)\n            throw illegal(\"token '\" + actual + \"', '\" + expected + \"' expected\");\n        return false;\n    }\n\n    /**\n     * Gets a comment.\n     * @param {number} [trailingLine] Line number if looking for a trailing comment\n     * @returns {string|null} Comment text\n     * @inner\n     */\n    function cmnt(trailingLine) {\n        var ret = null;\n        if (trailingLine === undefined) {\n            if (commentLine === line - 1 && (alternateCommentMode || commentType === \"*\" || commentLineEmpty)) {\n                ret = commentText;\n            }\n        } else {\n            /* istanbul ignore else */\n            if (commentLine < trailingLine) {\n                peek();\n            }\n            if (commentLine === trailingLine && !commentLineEmpty && (alternateCommentMode || commentType === \"/\")) {\n                ret = commentText;\n            }\n        }\n        return ret;\n    }\n\n    return Object.defineProperty({\n        next: next,\n        peek: peek,\n        push: push,\n        skip: skip,\n        cmnt: cmnt\n    }, \"line\", {\n        get: function() { return line; }\n    });\n    /* eslint-enable callback-return */\n}\n","/**\n * Created by zhangmiao on 2018/3/13.\n */\n\n\nmodule.exports = Type;\n\nvar Namespace = require(17);\n((Type.prototype = Object.create(Namespace.prototype)).constructor = Type).className = \"Type\";\n\n\nvar Enum,\n    Field,\n    Message,\n    OneOf,\n    Writer,\n    Reader,\n    util,\n    verifier,\n    encoder,\n    decoder,\n    Service,\n    wrappers,\n    converter,\n    MapField;\n\n\n\nfunction Type(name, options) {\n    Namespace.call(this, name, options);\n\n    /**\n     * Message fields.\n     * @type {Object.<string,Field>}\n     */\n    this.fields = {};  // toJSON, marker\n\n    /**\n     * Oneofs declared within this namespace, if any.\n     * @type {Object.<string,OneOf>}\n     */\n    this.oneofs = undefined; // toJSON\n\n    /**\n     * Extension ranges, if any.\n     * @type {number[][]}\n     */\n    this.extensions = undefined; // toJSON\n\n    /**\n     * Reserved ranges, if any.\n     * @type {Array.<number[]|string>}\n     */\n    this.reserved = undefined; // toJSON\n\n    /*?\n     * Whether this type is a legacy group.\n     * @type {boolean|undefined}\n     */\n    this.group = undefined; // toJSON ,\n\n    /**\n     * Cached fields by id.\n     * @type {Object.<number,Field>|null}\n     * @private\n     */\n    this._fieldsById = null;\n\n    /**\n     * Cached fields as an array.\n     * @type {Field[]|null}\n     * @private\n     */\n    this._fieldsArray = null;\n\n    /**\n     * Cached oneofs as an array.\n     * @type {OneOf[]|null}\n     * @private\n     */\n    this._oneofsArray = null;\n\n    /**\n     * Cached constructor.\n     * @type {Constructor<{}>}\n     * @private\n     */\n    this._ctor = null;\n}\n\n\nObject.defineProperties(Type.prototype, {\n\n    /**\n     * Message fields by id.\n     * @name Type#fieldsById\n     * @type {Object.<number,Field>}\n     * @readonly\n     */\n    fieldsById: {\n        get: function() {\n\n            /* istanbul ignore if */\n            if (this._fieldsById)\n                return this._fieldsById;\n\n            this._fieldsById = {};\n            for (var names = Object.keys(this.fields), i = 0; i < names.length; ++i) {\n                var field = this.fields[names[i]],\n                    id = field.id;\n\n                /* istanbul ignore if */\n                if (this._fieldsById[id])\n                    throw Error(\"duplicate id \" + id + \" in \" + this);\n\n                this._fieldsById[id] = field;\n            }\n            return this._fieldsById;\n        }\n    },\n\n    /**\n     * Fields of this message as an array for iteration.\n     * @name Type#fieldsArray\n     * @type {Field[]}\n     * @readonly\n     */\n    fieldsArray: {\n        get: function() {\n            return this._fieldsArray || (this._fieldsArray = util.toArray(this.fields));\n        }\n    },\n\n    /**\n     * Oneofs of this message as an array for iteration.\n     * @name Type#oneofsArray\n     * @type {OneOf[]}\n     * @readonly\n     */\n    oneofsArray: {\n        get: function() {\n            return this._oneofsArray || (this._oneofsArray = util.toArray(this.oneofs));\n        }\n    },\n\n    /**\n     * The registered constructor, if any registered, otherwise a generic constructor.\n     * Assigning a function replaces the internal constructor. If the function does not extend {@link Message} yet, its prototype will be setup accordingly and static methods will be populated. If it already extends {@link Message}, it will just replace the internal constructor.\n     * @name Type#ctor\n     * @type {Constructor<{}>}\n     */\n    ctor: {\n        get: function() {\n            return this._ctor || (this.ctor = Type.generateConstructor(this));\n        },\n        set: function(ctor) {\n\n            // Ensure proper prototype\n            var prototype = ctor.prototype;\n            if (!(prototype instanceof Message)) {\n                (ctor.prototype = new Message()).constructor = ctor;\n                util.merge(ctor.prototype, prototype);\n            }\n\n            // Classes and messages reference their reflected type\n            ctor.$type = ctor.prototype.$type = this;\n\n            // Mix in static methods\n            util.merge(ctor, Message, true);\n            util.merge(ctor.prototype, Message, true);\n\n\n            this._ctor = ctor;\n\n            // Messages have non-enumerable default values on their prototype\n            var i = 0;\n            for (; i < /* initializes */ this.fieldsArray.length; ++i)\n                this._fieldsArray[i].resolve(); // ensures a proper value\n\n            // Messages have non-enumerable getters and setters for each virtual oneof field\n            var ctorProperties = {};\n            for (i = 0; i < /* initializes */ this.oneofsArray.length; ++i) {\n                var oneofName = this._oneofsArray[i].resolve().name;\n\n                var oneOfGetAndSet = (function(fieldNames){\n                    var fieldMap = {};\n                    for (var i = 0; i < fieldNames.length; ++i)\n                        fieldMap[fieldNames[i]] = 0;\n\n                    return {\n                        setter : function (name){\n                            if(fieldNames.indexOf(name) < 0) return;\n                            fieldMap[name] = 1;\n                            for (var i = 0; i < fieldNames.length; ++i)\n                                if (fieldNames[i] !== name)\n                                    delete this[/*\"_\"+*/fieldNames[i]];\n                        },\n\n                        getter : function (){\n                            for (var keys = Object.keys(this), i = keys.length - 1; i > -1; --i)\n                                if (fieldMap[keys[i]] === 1 && this[keys[i]] !== undefined && this[keys[i]] !== null)\n                                    return keys[i];\n                        }\n\n                    }\n                })(this._oneofsArray[i].oneof);\n\n                ctorProperties[oneofName] = {\n                    get: oneOfGetAndSet.getter,\n                    set: oneOfGetAndSet.setter\n                };\n                //var fieldNames = this._oneofsArray[i].oneof;\n                //for (var  j = 0 ; j < fieldNames.length; j++){\n                //    var fieldName = fieldNames[j];\n                //    ctorProperties[fieldName] = {\n                //        set : (function(oneofName, fieldName){\n                //            return function (value){\n                //                this[oneofName] = fieldName;\n                //                this[\"_\"+fieldName] = value;\n                //            }\n                //        })(oneofName , fieldName),\n                //        get : (function(fieldName){\n                //            return function (){\n                //                return this[\"_\"+fieldName];\n                //            }\n                //        })(fieldName)\n                //    }\n                //}\n            }\n\n            if (i) {\n                //util.merge(ctor.prototype, ctorProperties, true);\n                Object.defineProperties(ctor.prototype, ctorProperties);\n            }\n        }\n    }\n});\n\n\n//\nType.generateConstructor = function generateConstructor(mtype) {\n    return function (p){\n        for (var i = 0, field; i < mtype.fieldsArray.length; i++){\n            if((field = mtype._fieldsArray[i]).map){\n                this[field.name] = {};\n            }else if(field.repeated){\n                this[field.name] = [];\n            }\n        }\n\n        if(p){\n            for (var  ks = Object.keys(p), j = 0; j < ks.length; ++j) {\n                if (p[ks[j]] != null) {\n                    this[ks[j]] = p[ks[j]]\n                }\n            }\n        }\n    };\n};\n\n\nfunction clearCache(type) {\n    type._fieldsById = type._fieldsArray = type._oneofsArray = null;\n    delete type.encode;\n    delete type.decode;\n    delete type.verify;\n    return type;\n}\n\n\n\nType.fromJSON = function fromJSON(name, json) {\n    var type = new Type(name, json.options);\n    type.extensions = json.extensions;\n    type.reserved = json.reserved;\n    var names = Object.keys(json.fields),\n        i = 0;\n    for (; i < names.length; ++i)\n        type.add(\n            ( typeof json.fields[names[i]].keyType !== \"undefined\"\n                ? MapField.fromJSON\n                : Field.fromJSON )(names[i], json.fields[names[i]])\n        );\n    if (json.oneofs)\n        for (names = Object.keys(json.oneofs), i = 0; i < names.length; ++i)\n            type.add(OneOf.fromJSON(names[i], json.oneofs[names[i]]));\n    if (json.nested)\n        for (names = Object.keys(json.nested), i = 0; i < names.length; ++i) {\n            var nested = json.nested[names[i]];\n            type.add( // most to least likely\n                ( nested.id !== undefined\n                    ? Field.fromJSON\n                    : nested.fields !== undefined\n                    ? Type.fromJSON\n                    : nested.values !== undefined\n                    ? Enum.fromJSON\n                    : nested.methods !== undefined\n                    ? Service.fromJSON\n                    : Namespace.fromJSON )(names[i], nested)\n            );\n        }\n    if (json.extensions && json.extensions.length)\n        type.extensions = json.extensions;\n    if (json.reserved && json.reserved.length)\n        type.reserved = json.reserved;\n    if (json.group)\n        type.group = true;\n    if (json.comment)\n        type.comment = json.comment;\n    return type;\n};\n\nType.prototype.toJSON = function toJSON(toJSONOptions) {\n    var inherited = Namespace.prototype.toJSON.call(this, toJSONOptions);\n    var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;\n\n    return {\n        \"options\"       : inherited && inherited.options || undefined,\n        \"oneofs\"        : Namespace.arrayToJSON(this.oneofsArray, toJSONOptions),\n        \"fields\"        : Namespace.arrayToJSON(this.fieldsArray.filter(function(obj) { return !obj.declaringField; }), toJSONOptions) || {},\n        \"extensions\"    : this.extensions && this.extensions.length ? this.extensions : undefined,\n        \"reserved\"      : this.reserved && this.reserved.length ? this.reserved : undefined,\n        \"group\"         : this.group || undefined,\n        \"nested\"        : inherited && inherited.nested || undefined,\n        \"comment\"       : keepComments ? this.comment : undefined\n    };\n};\n\nType.prototype.resolveAll = function resolveAll() {\n    var fields = this.fieldsArray, i = 0;\n    while (i < fields.length)\n        fields[i++].resolve();\n    var oneofs = this.oneofsArray; i = 0;\n    while (i < oneofs.length)\n        oneofs[i++].resolve();\n    return Namespace.prototype.resolveAll.call(this);\n};\n\nType.prototype.get = function get(name) {\n    return this.fields[name]\n        || this.oneofs && this.oneofs[name]\n        || this.nested && this.nested[name]\n        || null;\n};\n\nType.prototype.add = function add(object) {\n\n    if (this.get(object.name))\n        throw Error(\"duplicate name '\" + object.name + \"' in \" + this);\n\n    if (object instanceof Field && object.extend === undefined) {\n        if (this._fieldsById && this._fieldsById[object.id])\n            throw Error(\"duplicate id \" + object.id + \" in \" + this);\n        if (this.isReservedId(object.id))\n            throw Error(\"id \" + object.id + \" is reserved in \" + this);\n        if (this.isReservedName(object.name))\n            throw Error(\"name '\" + object.name + \"' is reserved in \" + this);\n\n        if (object.parent)\n            object.parent.remove(object);\n        this.fields[object.name] = object;\n        object.message = this;\n        object.onAdd(this);\n        return clearCache(this);\n    }\n    if (object instanceof OneOf) {\n        if (!this.oneofs)\n            this.oneofs = {};\n        this.oneofs[object.name] = object;\n        object.onAdd(this);\n        return clearCache(this);\n    }\n    return Namespace.prototype.add.call(this, object);\n};\n\nType.prototype.remove = function remove(object) {\n    if (object instanceof Field && object.extend === undefined) {\n        // See Type#add for the reason why extension fields are excluded here.\n\n        /* istanbul ignore if */\n        if (!this.fields || this.fields[object.name] !== object)\n            throw Error(object + \" is not a member of \" + this);\n\n        delete this.fields[object.name];\n        object.parent = null;\n        object.onRemove(this);\n        return clearCache(this);\n    }\n    if (object instanceof OneOf) {\n\n        /* istanbul ignore if */\n        if (!this.oneofs || this.oneofs[object.name] !== object)\n            throw Error(object + \" is not a member of \" + this);\n\n        delete this.oneofs[object.name];\n        object.parent = null;\n        object.onRemove(this);\n        return clearCache(this);\n    }\n    return Namespace.prototype.remove.call(this, object);\n};\n\nType.prototype.isReservedId = function isReservedId(id) {\n    return Namespace.isReservedId(this.reserved, id);\n};\n\nType.prototype.isReservedName = function isReservedName(name) {\n    return Namespace.isReservedName(this.reserved, name);\n};\n\nType.prototype.create = function create(properties) {\n    return new this.ctor(properties);\n};\n\n\nType.prototype.setup = function setup() {\n    // Sets up everything at once so that the prototype chain does not have to be re-evaluated\n    // multiple times (V8, soft-deopt prototype-check).\n\n    var fullName = this.fullName,\n        types    = [];\n    for (var i = 0; i < /* initializes */ this.fieldsArray.length; ++i)\n        types.push(this._fieldsArray[i].resolve().resolvedType);\n\n    // Replace setup methods with type-specific generated functions\n    this.encode = encoder(this)({\n        Writer : Writer,\n        types  : types,\n        util   : util\n    });\n\n\n    this.decode = decoder(this)({\n        Reader : Reader,\n        types  : types,\n        util   : util\n    });\n    this.verify = verifier(this)({\n        types : types,\n        util  : util\n    });\n\n    this.fromObject = converter.fromObject(this)({\n        types : types,\n        util  : util\n    });\n    this.toObject = converter.toObject(this)({\n        types : types,\n        util  : util\n    });\n\n    // Inject custom wrappers for common types\n    var wrapper = wrappers[fullName];\n    if (wrapper) {\n        var originalThis = Object.create(this);\n        // if (wrapper.fromObject) {\n        originalThis.fromObject = this.fromObject;\n        this.fromObject = wrapper.fromObject.bind(originalThis);\n        // }\n        // if (wrapper.toObject) {\n        originalThis.toObject = this.toObject;\n        this.toObject = wrapper.toObject.bind(originalThis);\n        // }\n    }\n\n    return this;\n};\n\n/**\n * Encodes a message of this type. Does not implicitly {@link Type#verify|verify} messages.\n * @param {Message<{}>|Object.<string,*>} message Message instance or plain object\n * @param {Writer} [writer] Writer to encode to\n * @returns {Writer} writer\n */\n\nType.prototype.encode = function encode_setup(message, writer) {\n    return this.setup().encode(message, writer); // overrides this method\n};\n\n/**\n * Encodes a message of this type preceeded by its byte length as a varint. Does not implicitly {@link Type#verify|verify} messages.\n * @param {Message<{}>|Object.<string,*>} message Message instance or plain object\n * @param {Writer} [writer] Writer to encode to\n * @returns {Writer} writer\n */\nType.prototype.encodeDelimited = function encodeDelimited(message, writer) {\n    return this.encode(message, writer && writer.len ? writer.fork() : writer).ldelim();\n};\n\n/**\n * Decodes a message of this type.\n * @param {Reader|Uint8Array|ArrayBuffer} reader Reader or buffer to decode from\n * @param {number} [length] Length of the message, if known beforehand\n * @returns {Message<{}>} Decoded message\n * @throws {Error} If the payload is not a reader or valid buffer\n */\n\nType.prototype.decode = function decode_setup(reader, length) {\n    return this.setup().decode(reader, length); // overrides this method\n};\n/**\n * Decodes a message of this type preceeded by its byte length as a varint.\n * @param {Reader|Uint8Array} reader Reader or buffer to decode from\n * @returns {Message<{}>} Decoded message\n * @throws {Error} If the payload is not a reader or valid buffer\n * @throws {util.ProtocolError} If required fields are missing\n */\nType.prototype.decodeDelimited = function decodeDelimited(reader) {\n    if (!(reader instanceof Reader))\n        reader = Reader.create(reader);\n    return this.decode(reader, reader.uint32());\n};\n\n/**\n * Verifies that field values are valid and that required fields are present.\n * @param {Object.<string,*>} message Plain object to verify\n * @returns {null|string} `null` if valid, otherwise the reason why it is not\n */\n\nType.prototype.verify = function verify_setup(message) {\n    return this.setup().verify(message); // overrides this method\n};\n\n/**\n * Creates a new message of this type from a plain object. Also converts values to their respective internal types.\n * @param {Object.<string,*>} object Plain object to convert\n * @returns {Message<{}>} Message instance\n */\nType.prototype.fromObject = function fromObject(object) {\n    return this.setup().fromObject(object);\n};\n\n/**\n * Conversion options as used by {@link Type#toObject} and {@link Message.toObject}.\n * @interface IConversionOptions\n * @property {Function} [longs] Long conversion type.\n * Valid values are `String` and `Number` (the global types).\n * Defaults to copy the present value, which is a possibly unsafe number without and a {@link Long} with a long library.\n * @property {Function} [enums] Enum value conversion type.\n * Only valid value is `String` (the global type).\n * Defaults to copy the present value, which is the numeric id.\n * @property {Function} [bytes] Bytes value conversion type.\n * Valid values are `Array` and (a base64 encoded) `String` (the global types).\n * Defaults to copy the present value, which usually is a Buffer under node and an Uint8Array in the browser.\n * @property {boolean} [defaults=false] Also sets default values on the resulting object\n * @property {boolean} [arrays=false] Sets empty arrays for missing repeated fields even if `defaults=false`\n * @property {boolean} [objects=false] Sets empty objects for missing map fields even if `defaults=false`\n * @property {boolean} [oneofs=false] Includes virtual oneof properties set to the present field's name, if any\n * @property {boolean} [json=false] Performs additional JSON compatibility conversions, i.e. NaN and Infinity to strings\n */\n\n/**\n * Creates a plain object from a message of this type. Also converts values to other types if specified.\n * @param {Message<{}>} message Message instance\n * @param {IConversionOptions} [options] Conversion options\n * @returns {Object.<string,*>} Plain object\n */\nType.prototype.toObject = function toObject(message, options) {\n    return this.setup().toObject(message, options);\n};\n\nType.d = function decorateType(typeName) {\n    return function typeDecorator(target) {\n        util.decorateType(target, typeName);\n    };\n};\n\nType._configure = function (){\n    Enum      = require(9);\n    Field     = require(10);\n    Message   = require(15);\n    OneOf     = require(19);\n    Writer    = require(35);\n    Reader    = require(23);\n    util      = require(32);\n    verifier  = require(33);\n    encoder   = require(8);\n    decoder   = require(7);\n    Service   = require(27);\n    wrappers  = require(34);\n    converter = require(6);\n    MapField  = require(14);\n\n};","\"use strict\";\n\n/**\n * Common type constants.\n * @namespace\n */\nvar types = module.exports;\nvar util = require(32);\n\nvar s = [\n    \"double\",   // 0\n    \"float\",    // 1\n    \"int32\",    // 2\n    \"uint32\",   // 3\n    \"sint32\",   // 4\n    \"fixed32\",  // 5\n    \"sfixed32\", // 6\n    \"int64\",    // 7\n    \"uint64\",   // 8\n    \"sint64\",   // 9\n    \"fixed64\",  // 10\n    \"sfixed64\", // 11\n    \"bool\",     // 12\n    \"string\",   // 13\n    \"bytes\"     // 14\n];\n\nfunction bake(values, offset) {\n    var i = 0, o = {};\n    offset |= 0;\n    while (i < values.length) o[s[i + offset]] = values[i++];\n    return o;\n}\n\n/**\n * Basic type wire types.\n * @type {Object.<string,number>}\n * @const\n * @property {number} double=1 Fixed64 wire type\n * @property {number} float=5 Fixed32 wire type\n * @property {number} int32=0 Varint wire type\n * @property {number} uint32=0 Varint wire type\n * @property {number} sint32=0 Varint wire type\n * @property {number} fixed32=5 Fixed32 wire type\n * @property {number} sfixed32=5 Fixed32 wire type\n * @property {number} int64=0 Varint wire type\n * @property {number} uint64=0 Varint wire type\n * @property {number} sint64=0 Varint wire type\n * @property {number} fixed64=1 Fixed64 wire type\n * @property {number} sfixed64=1 Fixed64 wire type\n * @property {number} bool=0 Varint wire type\n * @property {number} string=2 Ldelim wire type\n * @property {number} bytes=2 Ldelim wire type\n */\ntypes.basic = bake([\n    /* double   */ 1,\n    /* float    */ 5,\n    /* int32    */ 0,\n    /* uint32   */ 0,\n    /* sint32   */ 0,\n    /* fixed32  */ 5,\n    /* sfixed32 */ 5,\n    /* int64    */ 0,\n    /* uint64   */ 0,\n    /* sint64   */ 0,\n    /* fixed64  */ 1,\n    /* sfixed64 */ 1,\n    /* bool     */ 0,\n    /* string   */ 2,\n    /* bytes    */ 2\n]);\n\n/**\n * Basic type defaults.\n * @type {Object.<string,*>}\n * @const\n * @property {number} double=0 Double default\n * @property {number} float=0 Float default\n * @property {number} int32=0 Int32 default\n * @property {number} uint32=0 Uint32 default\n * @property {number} sint32=0 Sint32 default\n * @property {number} fixed32=0 Fixed32 default\n * @property {number} sfixed32=0 Sfixed32 default\n * @property {number} int64=0 Int64 default\n * @property {number} uint64=0 Uint64 default\n * @property {number} sint64=0 Sint32 default\n * @property {number} fixed64=0 Fixed64 default\n * @property {number} sfixed64=0 Sfixed64 default\n * @property {boolean} bool=false Bool default\n * @property {string} string=\"\" String default\n * @property {Array.<number>} bytes=Array(0) Bytes default\n * @property {null} message=null Message default\n */\ntypes.defaults = bake([\n    /* double   */ 0,\n    /* float    */ 0,\n    /* int32    */ 0,\n    /* uint32   */ 0,\n    /* sint32   */ 0,\n    /* fixed32  */ 0,\n    /* sfixed32 */ 0,\n    /* int64    */ 0,\n    /* uint64   */ 0,\n    /* sint64   */ 0,\n    /* fixed64  */ 0,\n    /* sfixed64 */ 0,\n    /* bool     */ false,\n    /* string   */ \"\",\n    /* bytes    */ util.emptyArray,\n    /* message  */ null\n]);\n\n/**\n * Basic long type wire types.\n * @type {Object.<string,number>}\n * @const\n * @property {number} int64=0 Varint wire type\n * @property {number} uint64=0 Varint wire type\n * @property {number} sint64=0 Varint wire type\n * @property {number} fixed64=1 Fixed64 wire type\n * @property {number} sfixed64=1 Fixed64 wire type\n */\ntypes.long = bake([\n    /* int64    */ 0,\n    /* uint64   */ 0,\n    /* sint64   */ 0,\n    /* fixed64  */ 1,\n    /* sfixed64 */ 1\n], 7);\n\n/**\n * Allowed types for map keys with their associated wire type.\n * @type {Object.<string,number>}\n * @const\n * @property {number} int32=0 Varint wire type\n * @property {number} uint32=0 Varint wire type\n * @property {number} sint32=0 Varint wire type\n * @property {number} fixed32=5 Fixed32 wire type\n * @property {number} sfixed32=5 Fixed32 wire type\n * @property {number} int64=0 Varint wire type\n * @property {number} uint64=0 Varint wire type\n * @property {number} sint64=0 Varint wire type\n * @property {number} fixed64=1 Fixed64 wire type\n * @property {number} sfixed64=1 Fixed64 wire type\n * @property {number} bool=0 Varint wire type\n * @property {number} string=2 Ldelim wire type\n */\ntypes.mapKey = bake([\n    /* int32    */ 0,\n    /* uint32   */ 0,\n    /* sint32   */ 0,\n    /* fixed32  */ 5,\n    /* sfixed32 */ 5,\n    /* int64    */ 0,\n    /* uint64   */ 0,\n    /* sint64   */ 0,\n    /* fixed64  */ 1,\n    /* sfixed64 */ 1,\n    /* bool     */ 0,\n    /* string   */ 2\n], 2);\n\n/**\n * Allowed types for packed repeated fields with their associated wire type.\n * @type {Object.<string,number>}\n * @const\n * @property {number} double=1 Fixed64 wire type\n * @property {number} float=5 Fixed32 wire type\n * @property {number} int32=0 Varint wire type\n * @property {number} uint32=0 Varint wire type\n * @property {number} sint32=0 Varint wire type\n * @property {number} fixed32=5 Fixed32 wire type\n * @property {number} sfixed32=5 Fixed32 wire type\n * @property {number} int64=0 Varint wire type\n * @property {number} uint64=0 Varint wire type\n * @property {number} sint64=0 Varint wire type\n * @property {number} fixed64=1 Fixed64 wire type\n * @property {number} sfixed64=1 Fixed64 wire type\n * @property {number} bool=0 Varint wire type\n */\ntypes.packed = bake([\n    /* double   */ 1,\n    /* float    */ 5,\n    /* int32    */ 0,\n    /* uint32   */ 0,\n    /* sint32   */ 0,\n    /* fixed32  */ 5,\n    /* sfixed32 */ 5,\n    /* int64    */ 0,\n    /* uint64   */ 0,\n    /* sint64   */ 0,\n    /* fixed64  */ 1,\n    /* sfixed64 */ 1,\n    /* bool     */ 0\n]);\n\ntypes._configure = function (){\n    util = require(32);\n}\n","\"use strict\";\n\n/**\n * A minimal UTF8 implementation for number arrays.\n * @memberof util\n * @namespace\n */\nvar utf8 = module.exports;\n\n/**\n * Calculates the UTF8 byte length of a string.\n * @param {string} string String\n * @returns {number} Byte length\n */\nutf8.length = function utf8_length(string) {\n    var len = 0,\n        c = 0;\n    for (var i = 0; i < string.length; ++i) {\n        c = string.charCodeAt(i);\n        if (c < 128)\n            len += 1;\n        else if (c < 2048)\n            len += 2;\n        else if ((c & 0xFC00) === 0xD800 && (string.charCodeAt(i + 1) & 0xFC00) === 0xDC00) {\n            ++i;\n            len += 4;\n        } else\n            len += 3;\n    }\n    return len;\n};\n\n/**\n * Reads UTF8 bytes as a string.\n * @param {Uint8Array} buffer Source buffer\n * @param {number} start Source start\n * @param {number} end Source end\n * @returns {string} String read\n */\nutf8.read = function utf8_read(buffer, start, end) {\n    var len = end - start;\n    if (len < 1)\n        return \"\";\n    var parts = null,\n        chunk = [],\n        i = 0, // char offset\n        t;     // temporary\n    while (start < end) {\n        t = buffer[start++];\n        if (t < 128)\n            chunk[i++] = t;\n        else if (t > 191 && t < 224)\n            chunk[i++] = (t & 31) << 6 | buffer[start++] & 63;\n        else if (t > 239 && t < 365) {\n            t = ((t & 7) << 18 | (buffer[start++] & 63) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63) - 0x10000;\n            chunk[i++] = 0xD800 + (t >> 10);\n            chunk[i++] = 0xDC00 + (t & 1023);\n        } else\n            chunk[i++] = (t & 15) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63;\n        if (i > 8191) {\n            (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));\n            i = 0;\n        }\n    }\n    if (parts) {\n        if (i)\n            parts.push(String.fromCharCode.apply(String, chunk.slice(0, i)));\n        return parts.join(\"\");\n    }\n    return String.fromCharCode.apply(String, chunk.slice(0, i));\n};\n\n/**\n * Writes a string as UTF8 bytes.\n * @param {string} string Source string\n * @param {Uint8Array} buffer Destination buffer\n * @param {number} offset Destination offset\n * @returns {number} Bytes written\n */\nutf8.write = function utf8_write(string, buffer, offset) {\n    var start = offset,\n        c1, // character 1\n        c2; // character 2\n    for (var i = 0; i < string.length; ++i) {\n        c1 = string.charCodeAt(i);\n        if (c1 < 128) {\n            buffer[offset++] = c1;\n        } else if (c1 < 2048) {\n            buffer[offset++] = c1 >> 6       | 192;\n            buffer[offset++] = c1       & 63 | 128;\n        } else if ((c1 & 0xFC00) === 0xD800 && ((c2 = string.charCodeAt(i + 1)) & 0xFC00) === 0xDC00) {\n            c1 = 0x10000 + ((c1 & 0x03FF) << 10) + (c2 & 0x03FF);\n            ++i;\n            buffer[offset++] = c1 >> 18      | 240;\n            buffer[offset++] = c1 >> 12 & 63 | 128;\n            buffer[offset++] = c1 >> 6  & 63 | 128;\n            buffer[offset++] = c1       & 63 | 128;\n        } else {\n            buffer[offset++] = c1 >> 12      | 224;\n            buffer[offset++] = c1 >> 6  & 63 | 128;\n            buffer[offset++] = c1       & 63 | 128;\n        }\n    }\n    return offset - start;\n};\n","/**\n * Created by zhangmiao on 2018/3/12.\n */\nvar util = module.exports;\n\nvar roots = require(25);\nutil.LongBits = require(13);\nutil.Long  = require(12);\nutil.pool = require(22);\nutil.float = require(11);\nutil.asPromise = require(3);\nutil.EventEmitter = require(2);\nutil.path = require(21);\nutil.base64 =require(4);\nutil.utf8 = require(31);\n\nutil.compareFieldsById = function compareFieldsById(a, b){\n    return a.id - b.id;\n};\n\nutil.toArray = function toArray(object) {\n    if (object) {\n        var keys  = Object.keys(object),\n            array = new Array(keys.length),\n            index = 0;\n        while (index < keys.length)\n            array[index] = object[keys[index++]];\n        return array;\n    }\n    return [];\n};\n\nutil.toObject = function toObject(array) {\n    var object = {},\n        index  = 0;\n    while (index < array.length) {\n        var key = array[index++],\n            val = array[index++];\n        if (val !== undefined)\n            object[key] = val;\n    }\n    return object;\n};\n\nutil.isString = function isString(value) {\n    return typeof value === \"string\" || value instanceof String;\n};\n\nvar safePropBackslashRe = /\\\\/g,\n    safePropQuoteRe     = /\"/g;\n\n/**\n * Tests whether the specified name is a reserved word in JS.\n * @param {string} name Name to test\n * @returns {boolean} `true` if reserved, otherwise `false`\n */\nutil.isReserved = function isReserved(name) {\n    return /^(?:do|if|in|for|let|new|try|var|case|else|enum|eval|false|null|this|true|void|with|break|catch|class|const|super|throw|while|yield|delete|export|import|public|return|static|switch|typeof|default|extends|finally|package|private|continue|debugger|function|arguments|interface|protected|implements|instanceof)$/.test(name);\n};\n\nutil.isObject = function isObject(value) {\n    return value && typeof value === \"object\";\n};\n\nutil.Array = typeof Uint8Array !== \"undefined\" ? Uint8Array /* istanbul ignore next */ : Array;\n\nutil.oneOfGetter = function getOneOf(fieldNames) {\n    var fieldMap = {};\n    for (var i = 0; i < fieldNames.length; ++i)\n        fieldMap[fieldNames[i]] = 1;\n\n    /**\n     * @returns {string|undefined} Set field name, if any\n     * @this Object\n     * @ignore\n     */\n    return function() { // eslint-disable-line consistent-return\n        for (var keys = Object.keys(this), i = keys.length - 1; i > -1; --i)\n            if (fieldMap[keys[i]] === 1 && this[keys[i]] !== undefined && this[keys[i]] !== null)\n                return keys[i];\n    };\n};\n\nutil.oneOfSetter = function setOneOf(fieldNames) {\n\n    /**\n     * @param {string} name Field name\n     * @returns {undefined}\n     * @this Object\n     * @ignore\n     */\n    return function(name) {\n        for (var i = 0; i < fieldNames.length; ++i)\n            if (fieldNames[i] !== name)\n                delete this[/*\"_\"+*/fieldNames[i]];//\n    };\n};\n\n\nutil.merge = function merge(dst, src, ifNotSet) { // used by converters\n    for (var keys = Object.keys(src), i = 0; i < keys.length; ++i)\n        if (dst[keys[i]] === undefined || !ifNotSet)\n            dst[keys[i]] = src[keys[i]];\n    return dst;\n};\n\nutil.decorateType = function decorateType(ctor, typeName) {\n\n    /* istanbul ignore if */\n    if (ctor.$type) {\n        if (typeName && ctor.$type.name !== typeName) {\n            util.decorateRoot.remove(ctor.$type);\n            ctor.$type.name = typeName;\n            util.decorateRoot.add(ctor.$type);\n        }\n        return ctor.$type;\n    }\n\n    /* istanbul ignore next */\n    if (!Type)\n        Type = require(29);\n\n    var type = new Type(typeName || ctor.name);\n    util.decorateRoot.add(type);\n    type.ctor = ctor; // sets up .encode, .decode etc.\n    Object.defineProperty(ctor, \"$type\", { value: type, enumerable: false });\n    Object.defineProperty(ctor.prototype, \"$type\", { value: type, enumerable: false });\n    return type;\n};\n\nutil.emptyArray = Object.freeze ? Object.freeze([]) : /* istanbul ignore next */ []; // used on prototypes\n\nutil.emptyObject = Object.freeze ? Object.freeze({}) : /* istanbul ignore next */ {}; // used on prototypes\n\nutil.longToHash = function longToHash(value) {\n    return value\n        ? util.LongBits.from(value).toHash()\n        : util.LongBits.zeroHash;\n};\n\nutil.copy = function(obj){\n    if(typeof obj != 'object'){\n        return obj;\n    }\n    var  newObj = {};\n    for (var  attr in obj) {\n        newObj[attr] = obj[attr];\n    }\n    return newObj;\n};\n\nfunction deepCopy(obj){\n    if(typeof obj != 'object'){\n        return obj;\n    }\n    var newobj = {};\n    for ( var attr in obj) {\n        newobj[attr] = deepCopy(obj[attr]);\n    }\n    return newobj;\n}\n\nutil.deepCopy = deepCopy;\n\nutil.ProtocolError =function newError(name) {\n\n    function CustomError(message, properties) {\n\n        if (!(this instanceof CustomError))\n            return new CustomError(message, properties);\n\n        // Error.call(this, message);\n        // ^ just returns a new error instance because the ctor can be called as a function\n\n        Object.defineProperty(this, \"message\", { get: function() { return message; } });\n\n        /* istanbul ignore next */\n        if (Error.captureStackTrace) // node\n            Error.captureStackTrace(this, CustomError);\n        else\n            Object.defineProperty(this, \"stack\", { value: (new Error()).stack || \"\" });\n\n        if (properties)\n            merge(this, properties);\n    }\n\n    (CustomError.prototype = Object.create(Error.prototype)).constructor = CustomError;\n\n    Object.defineProperty(CustomError.prototype, \"name\", { get: function() { return name; } });\n\n    CustomError.prototype.toString = function toString() {\n        return this.name + \": \" + this.message;\n    };\n\n    return CustomError;\n}\n\nutil.toJSONOptions = {\n    longs: String,\n    enums: String,\n    bytes: String,\n    json: true\n};\n\nutil.Buffer = (function() {\n    return null;\n})();\n\n\nutil.newBuffer = function newBuffer(sizeOrArray) {\n    /* istanbul ignore next */\n    return typeof sizeOrArray === \"number\"\n        ? new util.Array(sizeOrArray)\n        : typeof Uint8Array === \"undefined\"\n        ? sizeOrArray\n        : new Uint8Array(sizeOrArray);\n};\n\nutil.stringToBytes =function stringToBytes( str ) {\n    var bytes = [];\n    var len, c;\n    len = str.length;\n    for(var i = 0; i < len; i++) {\n        c = str.charCodeAt(i);\n        if(c >= 0x010000 && c <= 0x10FFFF) {\n            bytes.push(((c >> 18) & 0x07) | 0xF0);\n            bytes.push(((c >> 12) & 0x3F) | 0x80);\n            bytes.push(((c >> 6) & 0x3F) | 0x80);\n            bytes.push((c & 0x3F) | 0x80);\n        } else if(c >= 0x000800 && c <= 0x00FFFF) {\n            bytes.push(((c >> 12) & 0x0F) | 0xE0);\n            bytes.push(((c >> 6) & 0x3F) | 0x80);\n            bytes.push((c & 0x3F) | 0x80);\n        } else if(c >= 0x000080 && c <= 0x0007FF) {\n            bytes.push(((c >> 6) & 0x1F) | 0xC0);\n            bytes.push((c & 0x3F) | 0x80);\n        } else {\n            bytes.push(c & 0xFF);\n        }\n    }\n    return bytes;\n\n};\n\nutil.byteToString = function byteToString(arr) {\n    if(typeof arr === 'string') {\n        return arr;\n    }\n    var str = '',\n        _arr = arr;\n    for(var i = 0; i < _arr.length; i++) {\n        var one = _arr[i].toString(2),\n            v = one.match(/^1+?(?=0)/);\n        if(v && one.length == 8) {\n            var bytesLength = v[0].length;\n            var store = _arr[i].toString(2).slice(7 - bytesLength);\n            for(var st = 1; st < bytesLength; st++) {\n                store += _arr[st + i].toString(2).slice(2);\n            }\n            str += String.fromCharCode(parseInt(store, 2));\n            i += bytesLength - 1;\n        } else {\n            str += String.fromCharCode(_arr[i]);\n        }\n    }\n    return str;\n}\n\n\nutil.isInteger = Number.isInteger || /* istanbul ignore next */ function isInteger(value) {\n        return typeof value === \"number\" && isFinite(value) && Math.floor(value) === value;\n    };\n\nObject.defineProperty(util, \"decorateRoot\", {\n    get: function() {\n        return roots[\"decorated\"] || (roots[\"decorated\"] = new (require(24))());\n    }\n});\n","/**\n * Created by zhangmiao on 2018/3/14.\n */\nmodule.exports = verifier;\n\nvar Enum;\nvar util;\n\nfunction invalid(field, expected) {\n    return field.name + \": \" + expected + (field.repeated && expected !== \"array\" ? \"[]\" : field.map && expected !== \"object\" ? \"{k:\"+field.keyType+\"}\" : \"\") + \" expected\";\n}\n\nfunction verifyValue(field, fieldIndex, ref, options){\n    var _types = options.types;\n    if(field.resolvedType){\n        if(field.resolvedType instanceof Enum){\n            var keys = Object.keys(field.resolvedType.values);\n            if (keys.indexOf(ref)<0){\n                //\n                return invalid(field, \"enum value\");\n            }\n        }else {\n            var e = _types[fieldIndex].verify(ref);\n            if(e)\n                return field.name + \".\"+ e;\n        }\n    } else {\n        switch (field.type) {\n            case \"int32\":\n            case \"uint32\":\n            case \"sint32\":\n            case \"fixed32\":\n            case \"sfixed32\":\n                if (!util.isInteger(ref))\n                    return invalid(field, \"integer\");\n                break;\n            case \"int64\":\n            case \"uint64\":\n            case \"sint64\":\n            case \"fixed64\":\n            case \"sfixed64\":\n                if(!util.isInteger(ref)&&!(ref&&util.isInteger(ref.low)&&util.isInteger(ref.high)))\n                    return invalid(field, \"integer|Long\");\n                break;\n            case \"float\":\n            case \"double\":\n                if(typeof ref!==\"number\")\n                    return invalid(field, \"number\");\n                break;\n            case \"bool\":\n                if(typeof ref!==\"boolean\")\n                    return invalid(field, \"boolean\");\n                break;\n            case \"string\":\n                if(!util.isString(ref))\n                    return invalid(field, \"string\");\n                break;\n            case \"bytes\":\n                if(!(ref&&typeof ref.length===\"number\"||util.isString(ref)))\n                    return invalid(field, \"buffer\");\n                break;\n        }\n    }\n}\n\nfunction verifyKey(field, ref){\n    switch(field.keyType){\n        case \"int32\":\n        case \"uint32\":\n        case \"sint32\":\n        case \"fixed32\":\n        case \"sfixed32\":\n            if(!util.key32Re.test(ref))\n                return invalid(field, \"integer key\");\n            break;\n        case \"int64\":\n        case \"uint64\":\n        case \"sint64\":\n        case \"fixed64\":\n        case \"sfixed64\":\n            if(!util.key64Re.test(ref))\n                return invalid(field, \"integer|Long key\");\n            break;\n        case \"bool\":\n            if(!util.key2Re.test(ref))\n                return invalid(field, \"boolean key\");\n            break;\n    }\n}\n\nfunction verifier(mtype){\n    return function (options){\n        return function (m){\n            var invalidDes;\n            if(typeof m !== 'object' || m === null)\n                return \"object expected\";\n\n            var oneofs = mtype.oneofsArray,\n                seenFirstField = {};\n            var p;\n            if(oneofs.length)\n                p = {};\n            for (var i = 0; i < mtype.fieldsArray.length; ++i){\n                var field = mtype._fieldsArray[i].resolve(),\n                    ref   = m[field.name];\n                if(!field.optional || (ref!=null&& m.hasOwnProperty(field.name))){\n                    var  _i;\n                    if (field.map){\n                        if(!util.isObject(ref))\n                            return invalid(field, \"object\");\n                        var k=Object.keys(ref);\n                        for (_i = 0; _i < k.length; ++_i){\n                            //key\n                            invalidDes = verifyKey(field, k[_i]);\n                            if(invalidDes){\n                                return invalidDes;\n                            }\n                            //value\n                            invalidDes = verifyValue(field, i, ref[k[_i]], options);\n                            if(invalidDes){\n                                return invalidDes;\n                            }\n                        }\n                    } else if(field.repeated){\n                        if(!Array.isArray(ref)){\n                            return invalid(field, \"array\");\n                        }\n\n                        for (_i = 0; _i < ref.length; ++_i) {\n                            invalidDes = verifyValue(field, i, ref[_i], options);\n                            if(invalidDes){\n                                return invalidDes;\n                            }\n                        }\n                    } else {\n                        if(field.partOf) {\n                            var  oneofPropName = field.partOf.name;\n                            if (seenFirstField[field.partOf.name] === 1)\n                                if(p[oneofPropName] === 1)\n                                    return field.partOf.name + \": multiple values\";\n                            p[oneofPropName] = 1\n                        }\n                        invalidDes = verifyValue(field, i, ref, options);\n                        if(invalidDes){\n                            return invalidDes;\n                        }\n                    }\n                }\n            }\n        }\n    }\n}\n\nverifier._configure = function(){\n    Enum      = require(9);\n    util      = require(32);\n};","var wrappers = exports;\n\n\nvar Message;\n\n/**\n * From object converter part of an {@link IWrapper}.\n * @typedef WrapperFromObjectConverter\n * @type {function}\n * @param {Object.<string,*>} object Plain object\n * @returns {Message<{}>} Message instance\n * @this Type\n */\n\n/**\n * To object converter part of an {@link IWrapper}.\n * @typedef WrapperToObjectConverter\n * @type {function}\n * @param {Message<{}>} message Message instance\n * @param {IConversionOptions} [options] Conversion options\n * @returns {Object.<string,*>} Plain object\n * @this Type\n */\n\n/**\n * Common type wrapper part of {@link wrappers}.\n * @interface IWrapper\n * @property {WrapperFromObjectConverter} [fromObject] From object converter\n * @property {WrapperToObjectConverter} [toObject] To object converter\n */\n\n// Custom wrapper for Any\nwrappers[\".google.protobuf.Any\"] = {\n\n    fromObject: function(object) {\n\n        // unwrap value type if mapped\n        if (object && object[\"@type\"]) {\n            var type = this.lookup(object[\"@type\"]);\n            /* istanbul ignore else */\n            if (type) {\n                // type_url does not accept leading \".\"\n                var type_url = object[\"@type\"].charAt(0) === \".\" ?\n                    object[\"@type\"].substr(1) : object[\"@type\"];\n                // type_url prefix is optional, but path seperator is required\n                return this.create({\n                    type_url: \"/\" + type_url,\n                    value: type.encode(type.fromObject(object)).finish()\n                });\n            }\n        }\n\n        return this.fromObject(object);\n    },\n\n    toObject: function(message, options) {\n\n        // decode value if requested and unmapped\n        if (options && options.json && message.type_url && message.value) {\n            // Only use fully qualified type name after the last '/'\n            var name = message.type_url.substring(message.type_url.lastIndexOf(\"/\") + 1);\n            var type = this.lookup(name);\n            /* istanbul ignore else */\n            if (type)\n                message = type.decode(message.value);\n        }\n\n        // wrap value if unmapped\n        if (!(message instanceof this.ctor) && message instanceof Message) {\n            var object = message.$type.toObject(message, options);\n            object[\"@type\"] = message.$type.fullName;\n            return object;\n        }\n\n        return this.toObject(message, options);\n    }\n};\n\nwrappers._configure = function () {\n    Message = require(15);\n}","module.exports = Writer;\n\n\nvar util = require(32);\nvar LongBits;\n\nvar BufferWriter; // cyclic\n\nvar base64;\nvar utf8 = require(31);\n\n/**\n * Constructs a new writer operation instance.\n * @classdesc Scheduled writer operation.\n * @constructor\n * @param {function(*, Uint8Array, number)} fn Function to call\n * @param {number} len Value byte length\n * @param {*} val Value to write\n * @ignore\n */\nfunction Op(fn, len, val) {\n\n    /**\n     * Function to call.\n     * @type {function(Uint8Array, number, *)}\n     */\n    this.fn = fn;\n\n    /**\n     * Value byte length.\n     * @type {number}\n     */\n    this.len = len;\n\n    /**\n     * Next operation.\n     * @type {Writer.Op|undefined}\n     */\n    this.next = undefined;\n\n    /**\n     * Value to write.\n     * @type {*}\n     */\n    this.val = val; // type varies\n}\n\n/* istanbul ignore next */\nfunction noop() {} // eslint-disable-line no-empty-function\n\n/**\n * Constructs a new writer state instance.\n * @classdesc Copied writer state.\n * @memberof Writer\n * @constructor\n * @param {Writer} writer Writer to copy state from\n * @ignore\n */\nfunction State(writer) {\n\n    /**\n     * Current head.\n     * @type {Writer.Op}\n     */\n    this.head = writer.head;\n\n    /**\n     * Current tail.\n     * @type {Writer.Op}\n     */\n    this.tail = writer.tail;\n\n    /**\n     * Current buffer length.\n     * @type {number}\n     */\n    this.len = writer.len;\n\n    /**\n     * Next state.\n     * @type {State|null}\n     */\n    this.next = writer.states;\n}\n\n/**\n * Constructs a new writer instance.\n * @classdesc Wire format writer using `Uint8Array` if available, otherwise `Array`.\n * @constructor\n */\nfunction Writer() {\n\n    /**\n     * Current length.\n     * @type {number}\n     */\n    this.len = 0;\n\n    /**\n     * Operations head.\n     * @type {Object}\n     */\n    this.head = new Op(noop, 0, 0);\n\n    /**\n     * Operations tail\n     * @type {Object}\n     */\n    this.tail = this.head;\n\n    /**\n     * Linked forked states.\n     * @type {Object|null}\n     */\n    this.states = null;\n\n    // When a value is written, the writer calculates its byte length and puts it into a linked\n    // list of operations to perform when finish() is called. This both allows us to allocate\n    // buffers of the exact required size and reduces the amount of work we have to do compared\n    // to first calculating over objects and then encoding over objects. In our case, the encoding\n    // part is just a linked list walk calling operations with already prepared values.\n}\n\n/**\n * Creates a new writer.\n * @function\n * @returns {BufferWriter|Writer} A {@link BufferWriter} when Buffers are supported, otherwise a {@link Writer}\n */\nWriter.create = util.Buffer\n    ? function create_buffer_setup() {\n    return (Writer.create = function create_buffer() {\n        return new BufferWriter();\n    })();\n}\n    /* istanbul ignore next */\n    : function create_array() {\n    return new Writer();\n};\n\n/**\n * Allocates a buffer of the specified size.\n * @param {number} size Buffer size\n * @returns {Uint8Array} Buffer\n */\nWriter.alloc = function alloc(size) {\n    return new util.Array(size);\n};\n\n// Use Uint8Array buffer pool in the browser, just like node does with buffers\n/* istanbul ignore else */\nif (util.Array !== Array)\n    Writer.alloc = util.pool(Writer.alloc, util.Array.prototype.subarray);\n\n/**\n * Pushes a new operation to the queue.\n * @param {function(Uint8Array, number, *)} fn Function to call\n * @param {number} len Value byte length\n * @param {number} val Value to write\n * @returns {Writer} `this`\n * @private\n */\nWriter.prototype._push = function push(fn, len, val) {\n    this.tail = this.tail.next = new Op(fn, len, val);\n    this.len += len;\n    return this;\n};\n\nfunction writeByte(val, buf, pos) {\n    buf[pos] = val & 255;\n}\n\nfunction writeVarint32(val, buf, pos) {\n    while (val > 127) {\n        buf[pos++] = val & 127 | 128;\n        val >>>= 7;\n    }\n    buf[pos] = val;\n}\n\n/**\n * Constructs a new varint writer operation instance.\n * @classdesc Scheduled varint writer operation.\n * @extends Op\n * @constructor\n * @param {number} len Value byte length\n * @param {number} val Value to write\n * @ignore\n */\nfunction VarintOp(len, val) {\n    this.len = len;\n    this.next = undefined;\n    this.val = val;\n}\n\nVarintOp.prototype = Object.create(Op.prototype);\nVarintOp.prototype.fn = writeVarint32;\n\n/**\n * Writes an unsigned 32 bit value as a varint.\n * @param {number} value Value to write\n * @returns {Writer} `this`\n */\nWriter.prototype.uint32 = function write_uint32(value) {\n    // here, the call to this.push has been inlined and a varint specific Op subclass is used.\n    // uint32 is by far the most frequently used operation and benefits significantly from this.\n    this.len += (this.tail = this.tail.next = new VarintOp(\n        (value = value >>> 0) //\n        < 128       ? 1 //27\n            : value < 16384     ? 2 //214\n            : value < 2097152   ? 3 //221\n            : value < 268435456 ? 4 //228\n            :                     5, //235 32,5\n        value)).len;\n    return this;\n};\n\n/**\n * Writes a signed 32 bit value as a varint.\n * @function\n * @param {number} value Value to write\n * @returns {Writer} `this`\n */\nWriter.prototype.int32 = function write_int32(value) {\n    return value < 0\n        ? this._push(writeVarint64, 10, LongBits.fromNumber(value)) // 10 bytes per spec\n        : this.uint32(value);\n};\n\n/**\n * Writes a 32 bit value as a varint, zig-zag encoded.\n * @param {number} value Value to write\n * @returns {Writer} `this`\n */\nWriter.prototype.sint32 = function write_sint32(value) {\n    return this.uint32((value << 1 ^ value >> 31) >>> 0);\n};\n\nfunction writeVarint64(val, buf, pos) {\n    while (val.hi) {\n        buf[pos++] = val.lo & 127 | 128;\n        val.lo = (val.lo >>> 7 | val.hi << 25) >>> 0;\n        val.hi >>>= 7;\n    }\n    while (val.lo > 127) {\n        buf[pos++] = val.lo & 127 | 128;\n        val.lo = val.lo >>> 7;\n    }\n    buf[pos++] = val.lo;\n}\n\n/**\n * Writes an unsigned 64 bit value as a varint.\n * @param {Long|number|string} value Value to write\n * @returns {Writer} `this`\n * @throws {TypeError} If `value` is a string and no long library is present.\n */\nWriter.prototype.uint64 = function write_uint64(value) {\n    var bits = LongBits.from(value);\n    return this._push(writeVarint64, bits.length(), bits);\n};\n\n/**\n * Writes a signed 64 bit value as a varint.\n * @function\n * @param {Long|number|string} value Value to write\n * @returns {Writer} `this`\n * @throws {TypeError} If `value` is a string and no long library is present.\n */\nWriter.prototype.int64 = Writer.prototype.uint64;\n\n/**\n * Writes a signed 64 bit value as a varint, zig-zag encoded.\n * @param {Long|number|string} value Value to write\n * @returns {Writer} `this`\n * @throws {TypeError} If `value` is a string and no long library is present.\n */\nWriter.prototype.sint64 = function write_sint64(value) {\n    var bits = LongBits.from(value).zzEncode();\n    return this._push(writeVarint64, bits.length(), bits);\n};\n\n/**\n * Writes a boolish value as a varint.\n * @param {boolean} value Value to write\n * @returns {Writer} `this`\n */\nWriter.prototype.bool = function write_bool(value) {\n    return this._push(writeByte, 1, value ? 1 : 0);\n};\n\nfunction writeFixed32(val, buf, pos) {\n    buf[pos    ] =  val         & 255;\n    buf[pos + 1] =  val >>> 8   & 255;\n    buf[pos + 2] =  val >>> 16  & 255;\n    buf[pos + 3] =  val >>> 24;\n}\n\n/**\n * Writes an unsigned 32 bit value as fixed 32 bits.\n * @param {number} value Value to write\n * @returns {Writer} `this`\n */\nWriter.prototype.fixed32 = function write_fixed32(value) {\n    return this._push(writeFixed32, 4, value >>> 0);\n};\n\n/**\n * Writes a signed 32 bit value as fixed 32 bits.\n * @function\n * @param {number} value Value to write\n * @returns {Writer} `this`\n */\nWriter.prototype.sfixed32 = Writer.prototype.fixed32;\n\n/**\n * Writes an unsigned 64 bit value as fixed 64 bits.\n * @param {Long|number|string} value Value to write\n * @returns {Writer} `this`\n * @throws {TypeError} If `value` is a string and no long library is present.\n */\nWriter.prototype.fixed64 = function write_fixed64(value) {\n    var bits = LongBits.from(value);\n    return this._push(writeFixed32, 4, bits.lo)._push(writeFixed32, 4, bits.hi);\n};\n\n/**\n * Writes a signed 64 bit value as fixed 64 bits.\n * @function\n * @param {Long|number|string} value Value to write\n * @returns {Writer} `this`\n * @throws {TypeError} If `value` is a string and no long library is present.\n */\nWriter.prototype.sfixed64 = Writer.prototype.fixed64;\n\n/**\n * Writes a float (32 bit).\n * @function\n * @param {number} value Value to write\n * @returns {Writer} `this`\n */\nWriter.prototype.float = function write_float(value) {\n    return this._push(util.float.writeFloatLE, 4, value);\n};\n\n/**\n * Writes a double (64 bit float).\n * @function\n * @param {number} value Value to write\n * @returns {Writer} `this`\n */\nWriter.prototype.double = function write_double(value) {\n    return this._push(util.float.writeDoubleLE, 8, value);\n};\n\nvar writeBytes = util.Array.prototype.set\n    ? function writeBytes_set(val, buf, pos) {\n    buf.set(val, pos); // also works for plain array values\n}\n    /* istanbul ignore next */\n    : function writeBytes_for(val, buf, pos) {\n    for (var i = 0; i < val.length; ++i)\n        buf[pos + i] = val[i];\n};\n\n/**\n * Writes a sequence of bytes.\n * @param {Uint8Array|string} value Buffer or string to write\n * @returns {Writer} `this`\n */\nWriter.prototype.bytes = function write_bytes(value) {\n    var len = value.length >>> 0;\n    if (!len)\n        return this._push(writeByte, 1, 0);\n\n    if (util.isString(value)) {\n        //len = (value = util.stringToBytes(value)).length;\n        //var buf = Writer.alloc(len = base64.length(value));\n        //base64.decode(value, buf, 0);\n        //value = buf;\n        var buf = Writer.alloc(len = utf8.length(value));\n        utf8.write(value, buf, 0);\n        value = buf;\n    }\n    return this.uint32(len)._push(writeBytes, len, value);\n};\n\n/**\n * Writes a string.\n * @param {string} value Value to write\n * @returns {Writer} `this`\n */\nWriter.prototype.string = function write_string(value) {\n    var len = utf8.length(value);\n    return len\n        ? this.uint32(len)._push(utf8.write, len, value)\n        : this._push(writeByte, 1, 0);\n};\n\n/**\n * Forks this writer's state by pushing it to a stack.\n * Calling {@link Writer#reset|reset} or {@link Writer#ldelim|ldelim} resets the writer to the previous state.\n * @returns {Writer} `this`\n */\nWriter.prototype.fork = function fork() {\n    this.states = new State(this);\n    this.head = this.tail = new Op(noop, 0, 0);\n    this.len = 0;\n    return this;\n};\n\n/**\n * Resets this instance to the last state.\n * @returns {Writer} `this`\n */\nWriter.prototype.reset = function reset() {\n    if (this.states) {\n        this.head   = this.states.head;\n        this.tail   = this.states.tail;\n        this.len    = this.states.len;\n        this.states = this.states.next;\n    } else {\n        this.head = this.tail = new Op(noop, 0, 0);\n        this.len  = 0;\n    }\n    return this;\n};\n\n/**\n * Resets to the last state and appends the fork state's current write length as a varint followed by its operations.\n * @returns {Writer} `this`\n */\nWriter.prototype.ldelim = function ldelim() {\n    var head = this.head,\n        tail = this.tail,\n        len  = this.len;\n    this.reset().uint32(len);\n    if (len) {\n        this.tail.next = head.next; // skip noop\n        this.tail = tail;\n        this.len += len;\n    }\n    return this;\n};\n\n/**\n * Finishes the write operation.\n * @returns {Uint8Array} Finished buffer\n */\nWriter.prototype.finish = function finish() {\n    var head = this.head.next, // skip noop\n        buf  = this.constructor.alloc(this.len),\n        pos  = 0;\n    while (head) {\n        head.fn(head.val, buf, pos);\n        pos += head.len;\n        head = head.next;\n    }\n    // this.head = this.tail = null;\n    return buf;\n};\n\nWriter._configure = function() {\n\n    //util      = require(\"./util\");\n    LongBits  = require(13);\n    base64    = require(4);\n    utf8      = require(31);\n};\n"],"sourceRoot":"."}